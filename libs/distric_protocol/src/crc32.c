/**
 * @file crc32.c
 * @brief CRC32 Checksum Implementation
 *
 * Applied improvement:
 *
 *  Improvement #10 — Compile-time const CRC32 table; no pthread dependency.
 *    The previous revision built the table at runtime via pthread_once.
 *    Although race-free after Fix #2, it retained a libpthread dependency in
 *    a pure-computation module and required a pthread_once cost on every call.
 *
 *    The table is now `static const uint32_t[256]`, generated from the IEEE
 *    802.3 (Ethernet) reflected polynomial 0xEDB88320 by:
 *
 *        for i in 0..255:
 *            crc = i
 *            for _ in 0..7:
 *                crc = (crc >> 1) ^ 0xEDB88320  if (crc & 1) else  crc >> 1
 *            table[i] = crc
 *
 *    The script tools/gen_crc32_table.py produces this array; its output is
 *    checked against the test-vector CRC32("123456789") == 0xCBF43926 both
 *    at generation time (Python) and at runtime via test_crc32_known_vector.
 *
 *    crc32_init_table() is kept as a documented no-op for ABI compatibility.
 *    pthread.h is no longer included.
 *
 * Polynomial: 0x04C11DB7 (reflected: 0xEDB88320)
 */

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif

#include "distric_protocol/crc32.h"

/* ============================================================================
 * COMPILE-TIME CRC32 LOOKUP TABLE
 *
 * IEEE 802.3 reflected polynomial (0xEDB88320).
 * Generated by tools/gen_crc32_table.py — do not edit by hand.
 *
 * Verification:
 *   table[  0] == 0x00000000
 *   table[  1] == 0x77073096
 *   table[128] == 0xEDB88320   (the polynomial constant itself)
 *   table[255] == 0x2D02EF8D
 * ========================================================================= */

static const uint32_t crc32_table[256] = {
    /* 0x00 */ 0x00000000u, 0x77073096u, 0xEE0E612Cu, 0x990951BAu,
    /* 0x04 */ 0x076DC419u, 0x706AF48Fu, 0xE963A535u, 0x9E6495A3u,
    /* 0x08 */ 0x0EDB8832u, 0x79DCB8A4u, 0xE0D5E91Eu, 0x97D2D988u,
    /* 0x0C */ 0x09B64C2Bu, 0x7EB17CBDu, 0xE7B82D07u, 0x90BF1D91u,
    /* 0x10 */ 0x1DB71064u, 0x6AB020F2u, 0xF3B97148u, 0x84BE41DEu,
    /* 0x14 */ 0x1ADAD47Du, 0x6DDDE4EBu, 0xF4D4B551u, 0x83D385C7u,
    /* 0x18 */ 0x136C9856u, 0x646BA8C0u, 0xFD62F97Au, 0x8A65C9ECu,
    /* 0x1C */ 0x14015C4Fu, 0x63066CD9u, 0xFA0F3D63u, 0x8D080DF5u,
    /* 0x20 */ 0x3B6E20C8u, 0x4C69105Eu, 0xD56041E4u, 0xA2677172u,
    /* 0x24 */ 0x3C03E4D1u, 0x4B04D447u, 0xD20D85FDu, 0xA50AB56Bu,
    /* 0x28 */ 0x35B5A8FAu, 0x42B2986Cu, 0xDBBBC9D6u, 0xACBCF940u,
    /* 0x2C */ 0x32D86CE3u, 0x45DF5C75u, 0xDCD60DCFu, 0xABD13D59u,
    /* 0x30 */ 0x26D930ACu, 0x51DE003Au, 0xC8D75180u, 0xBFD06116u,
    /* 0x34 */ 0x21B4F4B5u, 0x56B3C423u, 0xCFBA9599u, 0xB8BDA50Fu,
    /* 0x38 */ 0x2802B89Eu, 0x5F058808u, 0xC60CD9B2u, 0xB10BE924u,
    /* 0x3C */ 0x2F6F7C87u, 0x58684C11u, 0xC1611DABu, 0xB6662D3Du,
    /* 0x40 */ 0x76DC4190u, 0x01DB7106u, 0x98D220BCu, 0xEFD5102Au,
    /* 0x44 */ 0x71B18589u, 0x06B6B51Fu, 0x9FBFE4A5u, 0xE8B8D433u,
    /* 0x48 */ 0x7807C9A2u, 0x0F00F934u, 0x9609A88Eu, 0xE10E9818u,
    /* 0x4C */ 0x7F6A0DBBu, 0x086D3D2Du, 0x91646C97u, 0xE6635C01u,
    /* 0x50 */ 0x6B6B51F4u, 0x1C6C6162u, 0x856530D8u, 0xF262004Eu,
    /* 0x54 */ 0x6C0695EDu, 0x1B01A57Bu, 0x8208F4C1u, 0xF50FC457u,
    /* 0x58 */ 0x65B0D9C6u, 0x12B7E950u, 0x8BBEB8EAu, 0xFCB9887Cu,
    /* 0x5C */ 0x62DD1DDFu, 0x15DA2D49u, 0x8CD37CF3u, 0xFBD44C65u,
    /* 0x60 */ 0x4DB26158u, 0x3AB551CEu, 0xA3BC0074u, 0xD4BB30E2u,
    /* 0x64 */ 0x4ADFA541u, 0x3DD895D7u, 0xA4D1C46Du, 0xD3D6F4FBu,
    /* 0x68 */ 0x4369E96Au, 0x346ED9FCu, 0xAD678846u, 0xDA60B8D0u,
    /* 0x6C */ 0x44042D73u, 0x33031DE5u, 0xAA0A4C5Fu, 0xDD0D7CC9u,
    /* 0x70 */ 0x5005713Cu, 0x270241AAu, 0xBE0B1010u, 0xC90C2086u,
    /* 0x74 */ 0x5768B525u, 0x206F85B3u, 0xB966D409u, 0xCE61E49Fu,
    /* 0x78 */ 0x5EDEF90Eu, 0x29D9C998u, 0xB0D09822u, 0xC7D7A8B4u,
    /* 0x7C */ 0x59B33D17u, 0x2EB40D81u, 0xB7BD5C3Bu, 0xC0BA6CADu,
    /* 0x80 */ 0xEDB88320u, 0x9ABFB3B6u, 0x03B6E20Cu, 0x74B1D29Au,
    /* 0x84 */ 0xEAD54739u, 0x9DD277AFu, 0x04DB2615u, 0x73DC1683u,
    /* 0x88 */ 0xE3630B12u, 0x94643B84u, 0x0D6D6A3Eu, 0x7A6A5AA8u,
    /* 0x8C */ 0xE40ECF0Bu, 0x9309FF9Du, 0x0A00AE27u, 0x7D079EB1u,
    /* 0x90 */ 0xF00F9344u, 0x8708A3D2u, 0x1E01F268u, 0x6906C2FEu,
    /* 0x94 */ 0xF762575Du, 0x806567CBu, 0x196C3671u, 0x6E6B06E7u,
    /* 0x98 */ 0xFED41B76u, 0x89D32BE0u, 0x10DA7A5Au, 0x67DD4ACCu,
    /* 0x9C */ 0xF9B9DF6Fu, 0x8EBEEFF9u, 0x17B7BE43u, 0x60B08ED5u,
    /* 0xA0 */ 0xD6D6A3E8u, 0xA1D1937Eu, 0x38D8C2C4u, 0x4FDFF252u,
    /* 0xA4 */ 0xD1BB67F1u, 0xA6BC5767u, 0x3FB506DDu, 0x48B2364Bu,
    /* 0xA8 */ 0xD80D2BDAu, 0xAF0A1B4Cu, 0x36034AF6u, 0x41047A60u,
    /* 0xAC */ 0xDF60EFC3u, 0xA867DF55u, 0x316E8EEFu, 0x4669BE79u,
    /* 0xB0 */ 0xCB61B38Cu, 0xBC66831Au, 0x256FD2A0u, 0x5268E236u,
    /* 0xB4 */ 0xCC0C7795u, 0xBB0B4703u, 0x220216B9u, 0x5505262Fu,
    /* 0xB8 */ 0xC5BA3BBEu, 0xB2BD0B28u, 0x2BB45A92u, 0x5CB36A04u,
    /* 0xBC */ 0xC2D7FFA7u, 0xB5D0CF31u, 0x2CD99E8Bu, 0x5BDEAE1Du,
    /* 0xC0 */ 0x9B64C2B0u, 0xEC63F226u, 0x756AA39Cu, 0x026D930Au,
    /* 0xC4 */ 0x9C0906A9u, 0xEB0E363Fu, 0x72076785u, 0x05005713u,
    /* 0xC8 */ 0x95BF4A82u, 0xE2B87A14u, 0x7BB12BAEu, 0x0CB61B38u,
    /* 0xCC */ 0x92D28E9Bu, 0xE5D5BE0Du, 0x7CDCEFB7u, 0x0BDBDF21u,
    /* 0xD0 */ 0x86D3D2D4u, 0xF1D4E242u, 0x68DDB3F8u, 0x1FDA836Eu,
    /* 0xD4 */ 0x81BE16CDu, 0xF6B9265Bu, 0x6FB077E1u, 0x18B74777u,
    /* 0xD8 */ 0x88085AE6u, 0xFF0F6A70u, 0x66063BCAu, 0x11010B5Cu,
    /* 0xDC */ 0x8F659EFFu, 0xF862AE69u, 0x616BFFD3u, 0x166CCF45u,
    /* 0xE0 */ 0xA00AE278u, 0xD70DD2EEu, 0x4E048354u, 0x3903B3C2u,
    /* 0xE4 */ 0xA7672661u, 0xD06016F7u, 0x4969474Du, 0x3E6E77DBu,
    /* 0xE8 */ 0xAED16A4Au, 0xD9D65ADCu, 0x40DF0B66u, 0x37D83BF0u,
    /* 0xEC */ 0xA9BCAE53u, 0xDEBB9EC5u, 0x47B2CF7Fu, 0x30B5FFE9u,
    /* 0xF0 */ 0xBDBDF21Cu, 0xCABAC28Au, 0x53B39330u, 0x24B4A3A6u,
    /* 0xF4 */ 0xBAD03605u, 0xCDD70693u, 0x54DE5729u, 0x23D967BFu,
    /* 0xF8 */ 0xB3667A2Eu, 0xC4614AB8u, 0x5D681B02u, 0x2A6F2B94u,
    /* 0xFC */ 0xB40BBE37u, 0xC30C8EA1u, 0x5A05DF1Bu, 0x2D02EF8Du,
};

_Static_assert(sizeof(crc32_table) == 256 * sizeof(uint32_t),
               "crc32_table must have exactly 256 uint32_t entries");

/* ============================================================================
 * PUBLIC INITIALISATION (no-op — kept for ABI compatibility)
 * ========================================================================= */

/**
 * @brief No-op stub kept for ABI compatibility.
 *
 * The table is now a compile-time constant; no initialisation is required.
 * Callers that previously called this function explicitly may continue to do
 * so safely.
 *
 * @deprecated Since improvement #10.  Will be removed in a future major version.
 */
void crc32_init_table(void)
{
    /* intentionally empty */
}

/* ============================================================================
 * CRC32 COMPUTATION
 * ========================================================================= */

/**
 * @brief Compute CRC32 over a data chunk with a caller-supplied running value.
 *
 * Streaming usage:
 * @code
 *   uint32_t crc = 0xFFFFFFFF;
 *   crc = compute_crc32_incremental(chunk1, len1, crc);
 *   crc = compute_crc32_incremental(chunk2, len2, crc);
 *   uint32_t final = ~crc;
 * @endcode
 */
uint32_t compute_crc32_incremental(const void* data, size_t len, uint32_t crc)
{
    if (!data || len == 0) return crc;

    const uint8_t* ptr = (const uint8_t*)data;
    for (size_t i = 0; i < len; i++) {
        uint8_t idx = (uint8_t)((crc ^ ptr[i]) & 0xFFu);
        crc = (crc >> 8) ^ crc32_table[idx];
    }
    return crc;
}

/**
 * @brief Compute CRC32 checksum over an entire buffer.
 *
 * Equivalent to: ~compute_crc32_incremental(data, len, 0xFFFFFFFF)
 *
 * @return 0 for NULL / empty input; CRC32 otherwise.
 */
uint32_t compute_crc32(const void* data, size_t len)
{
    if (!data || len == 0) return 0;
    uint32_t crc = compute_crc32_incremental(data, len, 0xFFFFFFFFu);
    return ~crc;
}