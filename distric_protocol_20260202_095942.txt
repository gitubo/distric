//####################
// FILE: /CMakeLists.txt
//####################

cmake_minimum_required(VERSION 3.15)

# Library: distric_protocol
project(distric_protocol VERSION 1.0.0 LANGUAGES C)

# Set C11 standard with GNU extensions
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)
set(CMAKE_C_EXTENSIONS ON)

# Compiler flags
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Wextra -Wpedantic -Werror")

# Find dependencies
find_package(Threads REQUIRED)

# Source files
set(PROTOCOL_SOURCES
    src/binary.c
    src/crc32.c
    src/tlv.c
    src/messages.c
)

# Create library
add_library(distric_protocol STATIC ${PROTOCOL_SOURCES})

# Set C11 properties explicitly with GNU extensions
set_target_properties(distric_protocol PROPERTIES
    C_STANDARD 11
    C_STANDARD_REQUIRED ON
    C_EXTENSIONS ON
)

# Include directories
target_include_directories(distric_protocol
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src
)

# Link dependencies
# Protocol layer depends on observability (for future metrics/logging)
target_link_libraries(distric_protocol
    PUBLIC
        distric_obs
        Threads::Threads
)

# Add tests
if(BUILD_TESTING)
    add_subdirectory(tests)
endif()

# Installation
install(TARGETS distric_protocol
    EXPORT distric_protocol-targets
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
    INCLUDES DESTINATION include
)

install(DIRECTORY include/
    DESTINATION include
    FILES_MATCHING PATTERN "*.h"
)



//####################
// FILE: /README.md
//####################

# DistriC Protocol Layer

Binary protocol implementation with fixed 32-byte headers, CRC32 checksums, and network byte order serialization.

## Features

- **Fixed 32-byte header**: Predictable, cache-friendly message structure
- **Network byte order**: Big-endian serialization for cross-platform compatibility
- **CRC32 checksums**: IEEE 802.3 polynomial for corruption detection
- **Message type system**: Organized by subsystem (Raft, Gossip, Task, Client)
- **Zero dependencies**: Only standard C library + distric_obs
- **Portable**: Tested on little-endian and big-endian systems

## Quick Start

### Include

```c
#include <distric_protocol.h>
```

### Create and Send Message

```c
// Initialize header
message_header_t header;
message_header_init(&header, MSG_RAFT_REQUEST_VOTE, payload_len);

// Create payload
uint8_t payload[1024];
// ... fill payload ...

// Compute CRC32
compute_header_crc32(&header, payload, payload_len);

// Serialize header
uint8_t wire_buffer[MESSAGE_HEADER_SIZE];
serialize_header(&header, wire_buffer);

// Send: wire_buffer (32 bytes) followed by payload
send(socket, wire_buffer, MESSAGE_HEADER_SIZE, 0);
send(socket, payload, payload_len, 0);
```

### Receive and Validate Message

```c
// Receive header
uint8_t wire_buffer[MESSAGE_HEADER_SIZE];
recv(socket, wire_buffer, MESSAGE_HEADER_SIZE, 0);

// Deserialize
message_header_t header;
deserialize_header(wire_buffer, &header);

// Validate header
if (!validate_message_header(&header)) {
    // Invalid header
    return;
}

// Receive payload
uint8_t* payload = malloc(header.payload_len);
recv(socket, payload, header.payload_len, 0);

// Verify CRC32
if (!verify_message_crc32(&header, payload, header.payload_len)) {
    // Corruption detected
    free(payload);
    return;
}

// Process message
printf("Message type: %s\n", message_type_to_string(header.msg_type));
// ...

free(payload);
```

## Message Header Structure

```
┌─────────────────────────────────────────┐
│  Offset | Size | Field                  │
├─────────┼──────┼────────────────────────┤
│  0      | 4    | Magic (0x44495354)     │
│  4      | 2    | Version (0x0001)       │
│  6      | 2    | Message Type           │
│  8      | 2    | Flags                  │
│  10     | 2    | Reserved               │
│  12     | 4    | Payload Length         │
│  16     | 8    | Message ID             │
│  24     | 4    | Timestamp (seconds)    │
│  28     | 4    | CRC32                  │
└─────────────────────────────────────────┘
Total: 32 bytes (packed, network byte order)
```

## Message Types

### Raft Consensus (0x1xxx)
- `MSG_RAFT_REQUEST_VOTE` (0x1001)
- `MSG_RAFT_APPEND_ENTRIES` (0x1003)
- `MSG_RAFT_INSTALL_SNAPSHOT` (0x1005)

### Gossip Protocol (0x2xxx)
- `MSG_GOSSIP_PING` (0x2001)
- `MSG_GOSSIP_ACK` (0x2002)
- `MSG_GOSSIP_MEMBERSHIP_UPDATE` (0x2004)

### Task Execution (0x3xxx)
- `MSG_TASK_ASSIGNMENT` (0x3001)
- `MSG_TASK_RESULT` (0x3002)
- `MSG_TASK_STATUS` (0x3003)

### Client API (0x4xxx)
- `MSG_CLIENT_SUBMIT` (0x4001)
- `MSG_CLIENT_RESPONSE` (0x4002)

## Message Flags

```c
MSG_FLAG_NONE           // No flags
MSG_FLAG_COMPRESSED     // Payload is compressed
MSG_FLAG_ENCRYPTED      // Payload is encrypted
MSG_FLAG_URGENT         // High-priority message
MSG_FLAG_RETRY          // This is a retry
MSG_FLAG_RESPONSE       // This is a response
```

## API Reference

### Header Initialization

```c
distric_err_t message_header_init(
    message_header_t* header,
    message_type_t msg_type,
    uint32_t payload_len
);
```

Initializes header with magic, version, unique message_id, and timestamp.

### Serialization

```c
distric_err_t serialize_header(
    const message_header_t* header,
    uint8_t* buffer
);
```

Converts header to network byte order (big-endian).

### Deserialization

```c
distric_err_t deserialize_header(
    const uint8_t* buffer,
    message_header_t* header
);
```

Converts from network byte order to host byte order.

### Validation

```c
bool validate_message_header(const message_header_t* header);
```

Checks magic, version, message type, and payload length.

### CRC32

```c
distric_err_t compute_header_crc32(
    message_header_t* header,
    const uint8_t* payload,
    size_t payload_len
);

bool verify_message_crc32(
    const message_header_t* header,
    const uint8_t* payload,
    size_t payload_len
);
```

Compute or verify CRC32 checksum over header + payload.

## Build

From project root:

```bash
# Configure
cmake -B build -DBUILD_TESTING=ON

# Build
cmake --build build

# Run tests
cd build && ctest -R test_binary --output-on-failure
```

## Testing

Run comprehensive test suite:

```bash
./build/libs/distric_protocol/tests/test_binary
```

Tests verify:
- Header size (exactly 32 bytes)
- Serialization/deserialization round-trip
- Network byte order conversion
- CRC32 computation and verification
- Corruption detection (single-bit errors)
- Message validation
- Unique message ID generation
- Portability across endianness

## Performance Characteristics

- **Header serialization**: ~50-100 ns
- **CRC32 computation**: ~5-10 cycles/byte (table-based)
- **Memory footprint**: 32 bytes per header
- **Cache-friendly**: Header fits in single cache line (64 bytes)

## Implementation Status

- [x] **Session 2.1**: Binary Protocol Foundation ✓
  - [x] Fixed 32-byte header structure
  - [x] Network byte order serialization
  - [x] CRC32 checksum (IEEE 802.3)
  - [x] Message validation
  - [x] Comprehensive tests
  
- [ ] **Session 2.2**: TLV Encoder/Decoder
- [ ] **Session 2.3**: Message Definitions
- [ ] **Session 2.4**: RPC Framework
- [ ] **Session 2.5**: Phase 2 Integration

**Phase 2 Progress**: 20% (1/5 sessions complete)

## Next Steps

Session 2.2 will implement Type-Length-Value (TLV) encoding for flexible payload serialization.

## License

TBD



//####################
// FILE: /include/distric_protocol.h
//####################

/**
 * @file distric_protocol.h
 * @brief DistriC Protocol Layer - Single Public Header
 * 
 * This is the ONLY header file that users of the distric_protocol library
 * need to include. It provides:
 * - Binary protocol message header structures
 * - Message serialization/deserialization
 * - CRC32 checksum computation
 * - TLV (Type-Length-Value) encoding/decoding
 * - Message type definitions
 * 
 * The protocol uses a fixed 32-byte header followed by variable-length payload.
 * Payloads are encoded using TLV format for flexibility and forward compatibility.
 * All multi-byte values are in network byte order (big-endian).
 * 
 * Usage Example:
 * @code
 * #include <distric_protocol.h>
 * 
 * // ===== Encoding a Message =====
 * 
 * // 1. Create TLV payload
 * tlv_encoder_t* enc = tlv_encoder_create(256);
 * tlv_encode_uint32(enc, FIELD_TERM, 42);
 * tlv_encode_string(enc, FIELD_CANDIDATE_ID, "node-123");
 * 
 * size_t payload_len;
 * uint8_t* payload = tlv_encoder_finalize(enc, &payload_len);
 * 
 * // 2. Create message header
 * message_header_t header;
 * message_header_init(&header, MSG_RAFT_REQUEST_VOTE, payload_len);
 * 
 * // 3. Compute CRC32 over header + payload
 * compute_header_crc32(&header, payload, payload_len);
 * 
 * // 4. Serialize header
 * uint8_t header_buf[MESSAGE_HEADER_SIZE];
 * serialize_header(&header, header_buf);
 * 
 * // 5. Send: header_buf (32 bytes) + payload
 * send(socket, header_buf, MESSAGE_HEADER_SIZE, 0);
 * send(socket, payload, payload_len, 0);
 * 
 * tlv_encoder_free(enc);
 * 
 * // ===== Decoding a Message =====
 * 
 * // 1. Receive header
 * uint8_t header_buf[MESSAGE_HEADER_SIZE];
 * recv(socket, header_buf, MESSAGE_HEADER_SIZE, 0);
 * 
 * // 2. Deserialize header
 * message_header_t header;
 * deserialize_header(header_buf, &header);
 * 
 * // 3. Validate header
 * if (!validate_message_header(&header)) {
 *     // Invalid header
 *     return;
 * }
 * 
 * // 4. Receive payload
 * uint8_t* payload = malloc(header.payload_len);
 * recv(socket, payload, header.payload_len, 0);
 * 
 * // 5. Verify CRC32
 * if (!verify_message_crc32(&header, payload, header.payload_len)) {
 *     // Corruption detected
 *     free(payload);
 *     return;
 * }
 * 
 * // 6. Decode TLV payload
 * tlv_decoder_t* dec = tlv_decoder_create(payload, header.payload_len);
 * tlv_field_t field;
 * 
 * while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
 *     switch (field.tag) {
 *         case FIELD_TERM:
 *             uint32_t term = tlv_field_as_uint32(&field);
 *             break;
 *         case FIELD_CANDIDATE_ID:
 *             const char* id = tlv_field_as_string(&field);
 *             break;
 *     }
 * }
 * 
 * tlv_decoder_free(dec);
 * free(payload);
 * @endcode
 * 
 * @version 1.0.0
 * @author DistriC Development Team
 */

#ifndef DISTRIC_PROTOCOL_H
#define DISTRIC_PROTOCOL_H

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * PROTOCOL LAYER MODULES
 * ========================================================================= */

/**
 * @defgroup binary Binary Protocol
 * @brief Fixed 32-byte message header with CRC32 checksums
 * 
 * Provides portable binary serialization with:
 * - Network byte order (big-endian)
 * - Magic number validation
 * - Version negotiation
 * - Message type identification
 * - CRC32 corruption detection
 * @{
 */
#include "distric_protocol/binary.h"
#include "distric_protocol/crc32.h"
/** @} */

/**
 * @defgroup tlv TLV Encoding
 * @brief Type-Length-Value flexible payload encoding
 * 
 * Provides self-describing binary format with:
 * - Dynamic buffer growth
 * - Zero-copy decoding
 * - Forward compatibility (unknown fields can be skipped)
 * - Type safety
 * - Network byte order
 * @{
 */
#include "distric_protocol/tlv.h"
/** @} */

/**
 * @defgroup messages Protocol Messages
 * @brief All protocol message definitions and serialization
 * 
 * Provides complete message structures for:
 * - Raft consensus (RequestVote, AppendEntries, InstallSnapshot)
 * - Gossip protocol (Ping, Ack, MembershipUpdate)
 * - Task execution (Assignment, Result, Status)
 * - Client API (Submit, Response, Query, Error)
 * 
 * All messages use TLV encoding internally.
 * @{
 */
#include "distric_protocol/messages.h"
/** @} */

/* ============================================================================
 * VERSION INFORMATION
 * ========================================================================= */

#define DISTRIC_PROTOCOL_VERSION_MAJOR 1
#define DISTRIC_PROTOCOL_VERSION_MINOR 0
#define DISTRIC_PROTOCOL_VERSION_PATCH 0

/**
 * @brief Get library version string
 * 
 * @return Version string (e.g., "1.0.0")
 */
static inline const char* distric_protocol_version(void) {
    return "1.0.0";
}

/* ============================================================================
 * TYPICAL USAGE WORKFLOW
 * ========================================================================= */

/**
 * @page protocol_workflow Protocol Usage Workflow
 * 
 * @section encoding Encoding Messages
 * 
 * 1. Create TLV encoder: `tlv_encoder_create()`
 * 2. Encode fields: `tlv_encode_uint32()`, `tlv_encode_string()`, etc.
 * 3. Finalize payload: `tlv_encoder_finalize()`
 * 4. Initialize header: `message_header_init()`
 * 5. Compute CRC32: `compute_header_crc32()`
 * 6. Serialize header: `serialize_header()`
 * 7. Send header + payload over network
 * 8. Cleanup: `tlv_encoder_free()`
 * 
 * @section decoding Decoding Messages
 * 
 * 1. Receive header (32 bytes)
 * 2. Deserialize header: `deserialize_header()`
 * 3. Validate header: `validate_message_header()`
 * 4. Receive payload (header.payload_len bytes)
 * 5. Verify CRC32: `verify_message_crc32()`
 * 6. Create TLV decoder: `tlv_decoder_create()`
 * 7. Decode fields: `tlv_decode_next()` in loop
 * 8. Extract values: `tlv_field_get_uint32()`, etc.
 * 9. Cleanup: `tlv_decoder_free()`
 */

#ifdef __cplusplus
}
#endif

#endif /* DISTRIC_PROTOCOL_H */



//####################
// FILE: /include/distric_protocol/binary.h
//####################

/**
 * @file binary.h
 * @brief Binary Protocol Header Definitions
 * 
 * Fixed 32-byte message header structure with network byte order.
 * 
 * Header Layout (32 bytes):
 * ┌─────────────────────────────────────────┐
 * │  Offset | Size | Field                  │
 * ├─────────┼──────┼────────────────────────┤
 * │  0      | 4    | Magic (0x44495354)     │
 * │  4      | 2    | Version (0x0001)       │
 * │  6      | 2    | Message Type           │
 * │  8      | 2    | Flags                  │
 * │  10     | 2    | Reserved               │
 * │  12     | 4    | Payload Length         │
 * │  16     | 8    | Message ID             │
 * │  24     | 4    | Timestamp (seconds)    │
 * │  28     | 4    | CRC32                  │
 * └─────────────────────────────────────────┘
 * 
 * @version 1.0.0
 */

#ifndef DISTRIC_PROTOCOL_BINARY_H
#define DISTRIC_PROTOCOL_BINARY_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <distric_obs.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * PROTOCOL CONSTANTS
 * ========================================================================= */

/** Protocol magic number: "DIST" in ASCII */
#define PROTOCOL_MAGIC 0x44495354

/** Current protocol version */
#define PROTOCOL_VERSION 0x0001

/** Fixed message header size (32 bytes) */
#define MESSAGE_HEADER_SIZE 32

/* ============================================================================
 * MESSAGE TYPES
 * ========================================================================= */

/**
 * @brief Message type enumeration
 * 
 * Message types are organized by subsystem:
 * - 0x1xxx: Raft consensus messages
 * - 0x2xxx: Gossip protocol messages
 * - 0x3xxx: Task execution messages
 * - 0x4xxx: Client API messages
 */
typedef enum {
    /* Raft consensus messages (0x1000-0x1FFF) */
    MSG_RAFT_REQUEST_VOTE           = 0x1001,
    MSG_RAFT_REQUEST_VOTE_RESPONSE  = 0x1002,
    MSG_RAFT_APPEND_ENTRIES         = 0x1003,
    MSG_RAFT_APPEND_ENTRIES_RESPONSE = 0x1004,
    MSG_RAFT_INSTALL_SNAPSHOT       = 0x1005,
    MSG_RAFT_INSTALL_SNAPSHOT_RESPONSE = 0x1006,
    
    /* Gossip protocol messages (0x2000-0x2FFF) */
    MSG_GOSSIP_PING                 = 0x2001,
    MSG_GOSSIP_ACK                  = 0x2002,
    MSG_GOSSIP_INDIRECT_PING        = 0x2003,
    MSG_GOSSIP_MEMBERSHIP_UPDATE    = 0x2004,
    MSG_GOSSIP_SUSPECT              = 0x2005,
    MSG_GOSSIP_ALIVE                = 0x2006,
    
    /* Task execution messages (0x3000-0x3FFF) */
    MSG_TASK_ASSIGNMENT             = 0x3001,
    MSG_TASK_RESULT                 = 0x3002,
    MSG_TASK_STATUS                 = 0x3003,
    MSG_TASK_CANCEL                 = 0x3004,
    MSG_TASK_HEARTBEAT              = 0x3005,
    
    /* Client API messages (0x4000-0x4FFF) */
    MSG_CLIENT_SUBMIT               = 0x4001,
    MSG_CLIENT_RESPONSE             = 0x4002,
    MSG_CLIENT_QUERY                = 0x4003,
    MSG_CLIENT_ERROR                = 0x4004,
} message_type_t;

/* ============================================================================
 * MESSAGE FLAGS
 * ========================================================================= */

/** Message flags (bitfield) */
#define MSG_FLAG_NONE           0x0000
#define MSG_FLAG_COMPRESSED     0x0001  /**< Payload is compressed */
#define MSG_FLAG_ENCRYPTED      0x0002  /**< Payload is encrypted */
#define MSG_FLAG_URGENT         0x0004  /**< High-priority message */
#define MSG_FLAG_RETRY          0x0008  /**< This is a retry */
#define MSG_FLAG_RESPONSE       0x0010  /**< This is a response */

/* ============================================================================
 * MESSAGE HEADER STRUCTURE
 * ========================================================================= */

/**
 * @brief Binary message header (32 bytes, packed)
 * 
 * All multi-byte fields are in network byte order (big-endian).
 * The header is designed for efficient parsing and cache-line alignment.
 */
typedef struct __attribute__((packed)) {
    uint32_t magic;         /**< Protocol magic (0x44495354 = "DIST") */
    uint16_t version;       /**< Protocol version (0x0001) */
    uint16_t msg_type;      /**< Message type (see message_type_t) */
    uint16_t flags;         /**< Message flags (bitfield) */
    uint16_t reserved;      /**< Reserved for future use (must be 0) */
    uint32_t payload_len;   /**< Payload length in bytes */
    uint64_t message_id;    /**< Unique message identifier */
    uint32_t timestamp;     /**< Unix timestamp (seconds since epoch) */
    uint32_t crc32;         /**< CRC32 checksum (header + payload) */
} message_header_t;

/* Compile-time assertion for header size */
_Static_assert(sizeof(message_header_t) == MESSAGE_HEADER_SIZE, 
               "message_header_t must be exactly 32 bytes");

/* ============================================================================
 * HEADER MANIPULATION API
 * ========================================================================= */

/**
 * @brief Initialize a message header with defaults
 * 
 * Sets magic, version, and generates a unique message_id.
 * Sets timestamp to current time.
 * CRC32 is computed separately via compute_header_crc32().
 * 
 * @param header Pointer to header to initialize
 * @param msg_type Message type
 * @param payload_len Length of payload in bytes
 * @return DISTRIC_OK on success, error code otherwise
 */
distric_err_t message_header_init(
    message_header_t* header,
    message_type_t msg_type,
    uint32_t payload_len
);

/**
 * @brief Serialize message header to buffer (network byte order)
 * 
 * Converts all multi-byte fields to big-endian and writes to buffer.
 * Buffer must be at least MESSAGE_HEADER_SIZE bytes.
 * 
 * @param header Header to serialize (host byte order)
 * @param buffer Output buffer (network byte order)
 * @return DISTRIC_OK on success, error code otherwise
 */
distric_err_t serialize_header(
    const message_header_t* header,
    uint8_t* buffer
);

/**
 * @brief Deserialize message header from buffer (network byte order)
 * 
 * Converts all multi-byte fields from big-endian to host byte order.
 * 
 * @param buffer Input buffer (network byte order)
 * @param header Output header (host byte order)
 * @return DISTRIC_OK on success, error code otherwise
 */
distric_err_t deserialize_header(
    const uint8_t* buffer,
    message_header_t* header
);

/**
 * @brief Validate message header
 * 
 * Checks:
 * - Magic number is correct
 * - Version is supported
 * - Message type is valid
 * - Payload length is reasonable
 * 
 * @param header Header to validate
 * @return true if valid, false otherwise
 */
bool validate_message_header(const message_header_t* header);

/**
 * @brief Compute and set CRC32 for header + payload
 * 
 * Computes CRC32 over the entire message (header + payload) and
 * stores it in header->crc32. The CRC field itself is zeroed before
 * computation.
 * 
 * @param header Header to update (in host byte order)
 * @param payload Payload data (or NULL if no payload)
 * @param payload_len Payload length in bytes
 * @return DISTRIC_OK on success, error code otherwise
 */
distric_err_t compute_header_crc32(
    message_header_t* header,
    const uint8_t* payload,
    size_t payload_len
);

/**
 * @brief Verify CRC32 of header + payload
 * 
 * Recomputes CRC32 and compares with header->crc32.
 * 
 * @param header Header to verify
 * @param payload Payload data (or NULL if no payload)
 * @param payload_len Payload length in bytes
 * @return true if CRC matches, false otherwise
 */
bool verify_message_crc32(
    const message_header_t* header,
    const uint8_t* payload,
    size_t payload_len
);

/**
 * @brief Get string representation of message type
 * 
 * @param msg_type Message type
 * @return Human-readable string (e.g., "RAFT_REQUEST_VOTE")
 */
const char* message_type_to_string(message_type_t msg_type);

#ifdef __cplusplus
}
#endif

#endif /* DISTRIC_PROTOCOL_BINARY_H */



//####################
// FILE: /include/distric_protocol/crc32.h
//####################

/**
 * @file crc32.h
 * @brief CRC32 Checksum Computation
 * 
 * Fast table-based CRC32 implementation using the IEEE 802.3 polynomial.
 * 
 * Polynomial: 0x04C11DB7 (reversed: 0xEDB88320)
 * 
 * @version 1.0.0
 */

#ifndef DISTRIC_PROTOCOL_CRC32_H
#define DISTRIC_PROTOCOL_CRC32_H

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * CRC32 API
 * ========================================================================= */

/**
 * @brief Compute CRC32 checksum over data
 * 
 * Uses table-based algorithm for fast computation.
 * Polynomial: 0xEDB88320 (IEEE 802.3, reversed)
 * 
 * @param data Input data
 * @param len Data length in bytes
 * @return CRC32 checksum
 */
uint32_t compute_crc32(const void* data, size_t len);

/**
 * @brief Compute CRC32 with initial value (for incremental computation)
 * 
 * Allows computing CRC32 over multiple data chunks:
 * 
 * @code
 * uint32_t crc = 0xFFFFFFFF;
 * crc = compute_crc32_incremental(chunk1, len1, crc);
 * crc = compute_crc32_incremental(chunk2, len2, crc);
 * crc = ~crc;  // Final inversion
 * @endcode
 * 
 * @param data Input data
 * @param len Data length in bytes
 * @param crc Initial CRC value
 * @return Updated CRC32 value
 */
uint32_t compute_crc32_incremental(const void* data, size_t len, uint32_t crc);

/**
 * @brief Initialize CRC32 lookup table
 * 
 * This function is called automatically on first use.
 * Can be called manually for predictable initialization timing.
 */
void crc32_init_table(void);

#ifdef __cplusplus
}
#endif

#endif /* DISTRIC_PROTOCOL_CRC32_H */



//####################
// FILE: /include/distric_protocol/messages.h
//####################

/**
 * @file messages.h
 * @brief Protocol Message Definitions
 * 
 * Defines all message structures used in the DistriC protocol:
 * - Raft consensus messages
 * - Gossip protocol messages
 * - Task execution messages
 * - Client API messages
 * 
 * Each message type has:
 * - Field tag constants
 * - C struct definition
 * - Serialization function
 * - Deserialization function
 * - Free function (if needed)
 * 
 * All messages are serialized using TLV encoding for flexibility
 * and forward compatibility.
 * 
 * @version 1.0.0
 */

#ifndef DISTRIC_PROTOCOL_MESSAGES_H
#define DISTRIC_PROTOCOL_MESSAGES_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <distric_obs.h>
#include "binary.h"
#include "tlv.h"

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * FIELD TAG DEFINITIONS
 * ========================================================================= */

/* Common fields (0x0000-0x00FF) */
#define FIELD_TERM                  0x0001  /**< Raft term number */
#define FIELD_NODE_ID               0x0002  /**< Node identifier */
#define FIELD_TIMESTAMP             0x0003  /**< Unix timestamp */
#define FIELD_SEQUENCE_NUMBER       0x0004  /**< Sequence number */

/* Raft fields (0x0100-0x01FF) */
#define FIELD_CANDIDATE_ID          0x0101  /**< Candidate node ID */
#define FIELD_LAST_LOG_INDEX        0x0102  /**< Last log index */
#define FIELD_LAST_LOG_TERM         0x0103  /**< Last log term */
#define FIELD_VOTE_GRANTED          0x0104  /**< Vote granted (bool) */
#define FIELD_LEADER_ID             0x0105  /**< Leader node ID */
#define FIELD_PREV_LOG_INDEX        0x0106  /**< Previous log index */
#define FIELD_PREV_LOG_TERM         0x0107  /**< Previous log term */
#define FIELD_ENTRIES               0x0108  /**< Log entries (array) */
#define FIELD_LEADER_COMMIT         0x0109  /**< Leader commit index */
#define FIELD_SUCCESS               0x010A  /**< Operation success (bool) */
#define FIELD_SNAPSHOT_INDEX        0x010B  /**< Snapshot last index */
#define FIELD_SNAPSHOT_TERM         0x010C  /**< Snapshot last term */
#define FIELD_SNAPSHOT_OFFSET       0x010D  /**< Snapshot chunk offset */
#define FIELD_SNAPSHOT_DATA         0x010E  /**< Snapshot chunk data */
#define FIELD_SNAPSHOT_DONE         0x010F  /**< Snapshot transfer done */

/* Log entry fields (0x0110-0x011F) */
#define FIELD_ENTRY_INDEX           0x0110  /**< Entry index */
#define FIELD_ENTRY_TERM            0x0111  /**< Entry term */
#define FIELD_ENTRY_DATA            0x0112  /**< Entry data */
#define FIELD_ENTRY_TYPE            0x0113  /**< Entry type */

/* Gossip fields (0x0200-0x02FF) */
#define FIELD_INCARNATION           0x0201  /**< Incarnation number */
#define FIELD_NODE_STATE            0x0202  /**< Node state */
#define FIELD_NODE_ADDRESS          0x0203  /**< Node address */
#define FIELD_NODE_PORT             0x0204  /**< Node port */
#define FIELD_NODE_ROLE             0x0205  /**< Node role (coordinator/worker) */
#define FIELD_SUSPECT_NODE_ID       0x0206  /**< Suspected node ID */
#define FIELD_PING_TARGET_ID        0x0207  /**< Ping target node ID */
#define FIELD_INDIRECT_TARGET_ID    0x0208  /**< Indirect ping target */
#define FIELD_MEMBERSHIP_UPDATES    0x0209  /**< Membership update array */
#define FIELD_PROTOCOL_VERSION      0x020A  /**< Protocol version */
#define FIELD_METADATA              0x020B  /**< Node metadata */

/* Task fields (0x0300-0x03FF) */
#define FIELD_TASK_ID               0x0301  /**< Task identifier */
#define FIELD_WORKFLOW_ID           0x0302  /**< Workflow identifier */
#define FIELD_TASK_TYPE             0x0303  /**< Task type/plugin name */
#define FIELD_TASK_CONFIG           0x0304  /**< Task configuration (JSON) */
#define FIELD_TASK_INPUT            0x0305  /**< Task input data */
#define FIELD_TASK_OUTPUT           0x0306  /**< Task output data */
#define FIELD_TASK_STATUS           0x0307  /**< Task status */
#define FIELD_TASK_ERROR            0x0308  /**< Task error message */
#define FIELD_TIMEOUT_SEC           0x0309  /**< Timeout in seconds */
#define FIELD_RETRY_COUNT           0x030A  /**< Retry count */
#define FIELD_WORKER_ID             0x030B  /**< Assigned worker ID */
#define FIELD_STARTED_AT            0x030C  /**< Start timestamp */
#define FIELD_COMPLETED_AT          0x030D  /**< Completion timestamp */
#define FIELD_EXIT_CODE             0x030E  /**< Task exit code */

/* Client fields (0x0400-0x04FF) */
#define FIELD_MESSAGE_ID            0x0401  /**< Message identifier */
#define FIELD_EVENT_TYPE            0x0402  /**< Event type */
#define FIELD_MESSAGE_PAYLOAD       0x0403  /**< Message payload (JSON) */
#define FIELD_RESPONSE_CODE         0x0404  /**< Response code */
#define FIELD_RESPONSE_MESSAGE      0x0405  /**< Response message */
#define FIELD_WORKFLOWS_TRIGGERED   0x0406  /**< Triggered workflow IDs */
#define FIELD_ERROR_CODE            0x0407  /**< Error code */
#define FIELD_ERROR_DETAILS         0x0408  /**< Error details */
#define FIELD_QUERY_TYPE            0x0409  /**< Query type */
#define FIELD_QUERY_PARAMS          0x040A  /**< Query parameters */

/* ============================================================================
 * RAFT MESSAGE STRUCTURES
 * ========================================================================= */

/**
 * @brief Raft RequestVote RPC
 * 
 * Sent by candidates to gather votes during leader election.
 */
typedef struct {
    uint32_t term;                  /**< Candidate's term */
    char candidate_id[64];          /**< Candidate requesting vote */
    uint32_t last_log_index;        /**< Index of candidate's last log entry */
    uint32_t last_log_term;         /**< Term of candidate's last log entry */
} raft_request_vote_t;

/**
 * @brief Raft RequestVote Response
 */
typedef struct {
    uint32_t term;                  /**< Current term, for candidate to update itself */
    bool vote_granted;              /**< True if candidate received vote */
    char node_id[64];               /**< Responder's node ID */
} raft_request_vote_response_t;

/**
 * @brief Raft log entry
 */
typedef struct {
    uint32_t index;                 /**< Log entry index */
    uint32_t term;                  /**< Term when entry was received */
    uint8_t* data;                  /**< Entry data */
    size_t data_len;                /**< Data length */
} raft_log_entry_t;

/**
 * @brief Raft AppendEntries RPC
 * 
 * Sent by leader to replicate log entries and heartbeat.
 */
typedef struct {
    uint32_t term;                  /**< Leader's term */
    char leader_id[64];             /**< Leader's ID */
    uint32_t prev_log_index;        /**< Index of log entry preceding new ones */
    uint32_t prev_log_term;         /**< Term of prev_log_index entry */
    raft_log_entry_t* entries;      /**< Log entries to store (NULL for heartbeat) */
    size_t entry_count;             /**< Number of entries */
    uint32_t leader_commit;         /**< Leader's commit index */
} raft_append_entries_t;

/**
 * @brief Raft AppendEntries Response
 */
typedef struct {
    uint32_t term;                  /**< Current term, for leader to update itself */
    bool success;                   /**< True if follower contained entry matching prev_log_* */
    char node_id[64];               /**< Responder's node ID */
    uint32_t last_log_index;        /**< Follower's last log index (for optimization) */
} raft_append_entries_response_t;

/**
 * @brief Raft InstallSnapshot RPC
 * 
 * Sent by leader to bring slow followers up to date.
 */
typedef struct {
    uint32_t term;                  /**< Leader's term */
    char leader_id[64];             /**< Leader's ID */
    uint32_t last_included_index;   /**< Snapshot replaces all entries up through this index */
    uint32_t last_included_term;    /**< Term of last_included_index */
    uint32_t offset;                /**< Byte offset where chunk is positioned */
    uint8_t* data;                  /**< Raw bytes of snapshot chunk */
    size_t data_len;                /**< Data length */
    bool done;                      /**< True if this is the last chunk */
} raft_install_snapshot_t;

/**
 * @brief Raft InstallSnapshot Response
 */
typedef struct {
    uint32_t term;                  /**< Current term, for leader to update itself */
    char node_id[64];               /**< Responder's node ID */
    bool success;                   /**< True if snapshot accepted */
} raft_install_snapshot_response_t;

/* ============================================================================
 * GOSSIP MESSAGE STRUCTURES
 * ========================================================================= */

/**
 * @brief Node state in gossip protocol
 */
typedef enum {
    NODE_STATE_ALIVE = 0,
    NODE_STATE_SUSPECTED = 1,
    NODE_STATE_FAILED = 2,
    NODE_STATE_LEFT = 3
} node_state_t;

/**
 * @brief Node role
 */
typedef enum {
    NODE_ROLE_COORDINATOR = 0,
    NODE_ROLE_WORKER = 1
} node_role_t;

/**
 * @brief Node information for gossip
 */
typedef struct {
    char node_id[64];               /**< Node identifier */
    char address[256];              /**< IP address or hostname */
    uint16_t port;                  /**< Port number */
    node_state_t state;             /**< Node state */
    node_role_t role;               /**< Node role */
    uint64_t incarnation;           /**< Incarnation number (for refutation) */
} gossip_node_info_t;

/**
 * @brief Gossip Ping message
 */
typedef struct {
    char sender_id[64];             /**< Sender's node ID */
    uint64_t incarnation;           /**< Sender's incarnation */
    uint32_t sequence_number;       /**< Ping sequence number */
} gossip_ping_t;

/**
 * @brief Gossip Ack message
 */
typedef struct {
    char sender_id[64];             /**< Responder's node ID */
    uint64_t incarnation;           /**< Responder's incarnation */
    uint32_t sequence_number;       /**< Ping sequence being acked */
} gossip_ack_t;

/**
 * @brief Gossip Indirect Ping message
 */
typedef struct {
    char sender_id[64];             /**< Original ping sender */
    char target_id[64];             /**< Target to ping */
    uint32_t sequence_number;       /**< Ping sequence number */
} gossip_indirect_ping_t;

/**
 * @brief Gossip Membership Update message
 */
typedef struct {
    char sender_id[64];             /**< Sender's node ID */
    gossip_node_info_t* updates;    /**< Array of node updates */
    size_t update_count;            /**< Number of updates */
} gossip_membership_update_t;

/* ============================================================================
 * TASK MESSAGE STRUCTURES
 * ========================================================================= */

/**
 * @brief Task status
 */
typedef enum {
    TASK_STATUS_PENDING = 0,
    TASK_STATUS_RUNNING = 1,
    TASK_STATUS_COMPLETED = 2,
    TASK_STATUS_FAILED = 3,
    TASK_STATUS_TIMEOUT = 4,
    TASK_STATUS_CANCELLED = 5
} task_status_t;

/**
 * @brief Task Assignment message
 * 
 * Sent from coordinator to worker to assign a task.
 */
typedef struct {
    char task_id[128];              /**< Task identifier */
    char workflow_id[128];          /**< Workflow identifier */
    char task_type[64];             /**< Task type/plugin name */
    char* config_json;              /**< Task configuration (JSON string) */
    uint8_t* input_data;            /**< Task input data */
    size_t input_data_len;          /**< Input data length */
    uint32_t timeout_sec;           /**< Timeout in seconds */
    uint32_t retry_count;           /**< Number of retries allowed */
} task_assignment_t;

/**
 * @brief Task Result message
 * 
 * Sent from worker to coordinator with task results.
 */
typedef struct {
    char task_id[128];              /**< Task identifier */
    char worker_id[64];             /**< Worker that executed task */
    task_status_t status;           /**< Final task status */
    uint8_t* output_data;           /**< Task output data */
    size_t output_data_len;         /**< Output data length */
    char* error_message;            /**< Error message (if failed) */
    int32_t exit_code;              /**< Task exit code */
    uint64_t started_at;            /**< Start timestamp (ms) */
    uint64_t completed_at;          /**< Completion timestamp (ms) */
} task_result_t;

/**
 * @brief Task Status message
 * 
 * Query or update for task status.
 */
typedef struct {
    char task_id[128];              /**< Task identifier */
    task_status_t status;           /**< Current status */
    uint32_t retry_count;           /**< Current retry count */
    char* status_message;           /**< Status message */
} task_status_msg_t;

/* ============================================================================
 * CLIENT MESSAGE STRUCTURES
 * ========================================================================= */

/**
 * @brief Client Submit message
 * 
 * Submit a message for processing.
 */
typedef struct {
    char message_id[128];           /**< Message identifier */
    char event_type[64];            /**< Event type */
    char* payload_json;             /**< Message payload (JSON) */
    uint64_t timestamp;             /**< Submission timestamp */
} client_submit_t;

/**
 * @brief Client Response message
 */
typedef struct {
    char message_id[128];           /**< Original message ID */
    uint32_t response_code;         /**< Response code (200=success, etc.) */
    char* response_message;         /**< Human-readable message */
    char** workflows_triggered;     /**< Array of triggered workflow IDs */
    size_t workflow_count;          /**< Number of workflows triggered */
} client_response_t;

/**
 * @brief Client Query message
 */
typedef struct {
    char query_id[128];             /**< Query identifier */
    char query_type[64];            /**< Type of query */
    char* query_params_json;        /**< Query parameters (JSON) */
} client_query_t;

/**
 * @brief Client Error message
 */
typedef struct {
    char message_id[128];           /**< Related message ID */
    uint32_t error_code;            /**< Error code */
    char* error_message;            /**< Error description */
    char* error_details;            /**< Detailed error info */
} client_error_t;

/* ============================================================================
 * SERIALIZATION FUNCTIONS - RAFT
 * ========================================================================= */

/**
 * @brief Serialize Raft RequestVote
 */
distric_err_t serialize_raft_request_vote(
    const raft_request_vote_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Raft RequestVote
 */
distric_err_t deserialize_raft_request_vote(
    const uint8_t* buffer,
    size_t len,
    raft_request_vote_t* msg_out
);

/**
 * @brief Serialize Raft RequestVote Response
 */
distric_err_t serialize_raft_request_vote_response(
    const raft_request_vote_response_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Raft RequestVote Response
 */
distric_err_t deserialize_raft_request_vote_response(
    const uint8_t* buffer,
    size_t len,
    raft_request_vote_response_t* msg_out
);

/**
 * @brief Serialize Raft AppendEntries
 */
distric_err_t serialize_raft_append_entries(
    const raft_append_entries_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Raft AppendEntries
 */
distric_err_t deserialize_raft_append_entries(
    const uint8_t* buffer,
    size_t len,
    raft_append_entries_t* msg_out
);

/**
 * @brief Free Raft AppendEntries (for entries array)
 */
void free_raft_append_entries(raft_append_entries_t* msg);

/**
 * @brief Serialize Raft AppendEntries Response
 */
distric_err_t serialize_raft_append_entries_response(
    const raft_append_entries_response_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Raft AppendEntries Response
 */
distric_err_t deserialize_raft_append_entries_response(
    const uint8_t* buffer,
    size_t len,
    raft_append_entries_response_t* msg_out
);

/* ============================================================================
 * SERIALIZATION FUNCTIONS - GOSSIP
 * ========================================================================= */

/**
 * @brief Serialize Gossip Ping
 */
distric_err_t serialize_gossip_ping(
    const gossip_ping_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Gossip Ping
 */
distric_err_t deserialize_gossip_ping(
    const uint8_t* buffer,
    size_t len,
    gossip_ping_t* msg_out
);

/**
 * @brief Serialize Gossip Ack
 */
distric_err_t serialize_gossip_ack(
    const gossip_ack_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Gossip Ack
 */
distric_err_t deserialize_gossip_ack(
    const uint8_t* buffer,
    size_t len,
    gossip_ack_t* msg_out
);

/**
 * @brief Serialize Gossip Membership Update
 */
distric_err_t serialize_gossip_membership_update(
    const gossip_membership_update_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Gossip Membership Update
 */
distric_err_t deserialize_gossip_membership_update(
    const uint8_t* buffer,
    size_t len,
    gossip_membership_update_t* msg_out
);

/**
 * @brief Free Gossip Membership Update (for updates array)
 */
void free_gossip_membership_update(gossip_membership_update_t* msg);

/* ============================================================================
 * SERIALIZATION FUNCTIONS - TASK
 * ========================================================================= */

/**
 * @brief Serialize Task Assignment
 */
distric_err_t serialize_task_assignment(
    const task_assignment_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Task Assignment
 */
distric_err_t deserialize_task_assignment(
    const uint8_t* buffer,
    size_t len,
    task_assignment_t* msg_out
);

/**
 * @brief Free Task Assignment (for allocated strings)
 */
void free_task_assignment(task_assignment_t* msg);

/**
 * @brief Serialize Task Result
 */
distric_err_t serialize_task_result(
    const task_result_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Task Result
 */
distric_err_t deserialize_task_result(
    const uint8_t* buffer,
    size_t len,
    task_result_t* msg_out
);

/**
 * @brief Free Task Result (for allocated data)
 */
void free_task_result(task_result_t* msg);

/* ============================================================================
 * SERIALIZATION FUNCTIONS - CLIENT
 * ========================================================================= */

/**
 * @brief Serialize Client Submit
 */
distric_err_t serialize_client_submit(
    const client_submit_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Client Submit
 */
distric_err_t deserialize_client_submit(
    const uint8_t* buffer,
    size_t len,
    client_submit_t* msg_out
);

/**
 * @brief Free Client Submit (for allocated strings)
 */
void free_client_submit(client_submit_t* msg);

/**
 * @brief Serialize Client Response
 */
distric_err_t serialize_client_response(
    const client_response_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
);

/**
 * @brief Deserialize Client Response
 */
distric_err_t deserialize_client_response(
    const uint8_t* buffer,
    size_t len,
    client_response_t* msg_out
);

/**
 * @brief Free Client Response (for allocated arrays)
 */
void free_client_response(client_response_t* msg);

/* ============================================================================
 * UTILITY FUNCTIONS
 * ========================================================================= */

/**
 * @brief Get string representation of node state
 */
const char* node_state_to_string(node_state_t state);

/**
 * @brief Get string representation of node role
 */
const char* node_role_to_string(node_role_t role);

/**
 * @brief Get string representation of task status
 */
const char* task_status_to_string(task_status_t status);

#ifdef __cplusplus
}
#endif

#endif /* DISTRIC_PROTOCOL_MESSAGES_H */



//####################
// FILE: /include/distric_protocol/tlv.h
//####################

/**
 * @file tlv.h
 * @brief Type-Length-Value (TLV) Encoding/Decoding
 * 
 * Flexible binary encoding system for protocol message payloads.
 * Each field is encoded as:
 *   [Type:1 byte][Tag:2 bytes][Length:4 bytes][Value:N bytes]
 * 
 * Features:
 * - Self-describing format (type information embedded)
 * - Forward/backward compatibility (unknown fields can be skipped)
 * - Dynamic buffer growth
 * - Nested structures (arrays, maps)
 * - Zero-copy decoding where possible
 * 
 * Wire Format:
 * ┌──────────────────────────────────────┐
 * │  Byte 0    | Type (uint8_t)          │
 * │  Bytes 1-2 | Tag (uint16_t, BE)      │
 * │  Bytes 3-6 | Length (uint32_t, BE)   │
 * │  Bytes 7+  | Value (N bytes)         │
 * └──────────────────────────────────────┘
 * 
 * Example Usage:
 * @code
 * // Encoding
 * tlv_encoder_t* enc = tlv_encoder_create(256);
 * tlv_encode_uint32(enc, FIELD_TERM, 42);
 * tlv_encode_string(enc, FIELD_NODE_ID, "node-123");
 * 
 * size_t len;
 * uint8_t* buffer = tlv_encoder_finalize(enc, &len);
 * send(socket, buffer, len, 0);
 * 
 * // Decoding
 * tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
 * tlv_field_t field;
 * 
 * while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
 *     if (field.tag == FIELD_TERM) {
 *         uint32_t term = tlv_field_as_uint32(&field);
 *     }
 * }
 * 
 * tlv_decoder_free(dec);
 * @endcode
 * 
 * @version 1.0.0
 */

#ifndef DISTRIC_PROTOCOL_TLV_H
#define DISTRIC_PROTOCOL_TLV_H

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <distric_obs.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * TLV TYPE DEFINITIONS
 * ========================================================================= */

/**
 * @brief TLV field types
 * 
 * Indicates the data type of the value portion.
 */
typedef enum {
    TLV_UINT8       = 0x01,    /**< Unsigned 8-bit integer */
    TLV_UINT16      = 0x02,    /**< Unsigned 16-bit integer */
    TLV_UINT32      = 0x03,    /**< Unsigned 32-bit integer */
    TLV_UINT64      = 0x04,    /**< Unsigned 64-bit integer */
    TLV_INT8        = 0x05,    /**< Signed 8-bit integer */
    TLV_INT16       = 0x06,    /**< Signed 16-bit integer */
    TLV_INT32       = 0x07,    /**< Signed 32-bit integer */
    TLV_INT64       = 0x08,    /**< Signed 64-bit integer */
    TLV_FLOAT       = 0x09,    /**< 32-bit float */
    TLV_DOUBLE      = 0x0A,    /**< 64-bit double */
    TLV_BOOL        = 0x0B,    /**< Boolean (1 byte: 0=false, 1=true) */
    TLV_STRING      = 0x10,    /**< UTF-8 string (length-prefixed, null-terminated) */
    TLV_BYTES       = 0x11,    /**< Raw byte array (length-prefixed) */
    TLV_ARRAY       = 0x20,    /**< Array of TLV fields */
    TLV_MAP         = 0x21,    /**< Key-value pairs (both keys and values are TLV) */
} tlv_type_t;

/* ============================================================================
 * TLV FIELD STRUCTURE
 * ========================================================================= */

/**
 * @brief Decoded TLV field
 * 
 * Represents a single field extracted from a TLV buffer.
 * The value pointer points into the original buffer (zero-copy).
 */
typedef struct {
    tlv_type_t type;        /**< Field type */
    uint16_t tag;           /**< Field identifier */
    uint32_t length;        /**< Length of value in bytes */
    const uint8_t* value;   /**< Pointer to value data (in original buffer) */
} tlv_field_t;

/* ============================================================================
 * TLV ENCODER
 * ========================================================================= */

/**
 * @brief TLV encoder state (opaque)
 */
typedef struct tlv_encoder tlv_encoder_t;

/**
 * @brief Create a new TLV encoder
 * 
 * Creates an encoder with an initial buffer capacity.
 * Buffer grows automatically as needed.
 * 
 * @param initial_capacity Initial buffer size in bytes
 * @return Encoder instance, or NULL on allocation failure
 */
tlv_encoder_t* tlv_encoder_create(size_t initial_capacity);

/**
 * @brief Free TLV encoder and its buffer
 * 
 * @param encoder Encoder to free
 */
void tlv_encoder_free(tlv_encoder_t* encoder);

/**
 * @brief Get current buffer size
 * 
 * @param encoder Encoder instance
 * @return Number of bytes written so far
 */
size_t tlv_encoder_size(const tlv_encoder_t* encoder);

/**
 * @brief Reset encoder (clear buffer, keep capacity)
 * 
 * @param encoder Encoder to reset
 */
void tlv_encoder_reset(tlv_encoder_t* encoder);

/* ============================================================================
 * ENCODING FUNCTIONS
 * ========================================================================= */

/**
 * @brief Encode unsigned 8-bit integer
 */
distric_err_t tlv_encode_uint8(tlv_encoder_t* enc, uint16_t tag, uint8_t value);

/**
 * @brief Encode unsigned 16-bit integer
 */
distric_err_t tlv_encode_uint16(tlv_encoder_t* enc, uint16_t tag, uint16_t value);

/**
 * @brief Encode unsigned 32-bit integer
 */
distric_err_t tlv_encode_uint32(tlv_encoder_t* enc, uint16_t tag, uint32_t value);

/**
 * @brief Encode unsigned 64-bit integer
 */
distric_err_t tlv_encode_uint64(tlv_encoder_t* enc, uint16_t tag, uint64_t value);

/**
 * @brief Encode signed 32-bit integer
 */
distric_err_t tlv_encode_int32(tlv_encoder_t* enc, uint16_t tag, int32_t value);

/**
 * @brief Encode signed 64-bit integer
 */
distric_err_t tlv_encode_int64(tlv_encoder_t* enc, uint16_t tag, int64_t value);

/**
 * @brief Encode boolean value
 */
distric_err_t tlv_encode_bool(tlv_encoder_t* enc, uint16_t tag, bool value);

/**
 * @brief Encode UTF-8 string
 * 
 * String is encoded with null terminator included.
 * 
 * @param enc Encoder instance
 * @param tag Field tag
 * @param str Null-terminated string (UTF-8)
 * @return DISTRIC_OK on success
 */
distric_err_t tlv_encode_string(tlv_encoder_t* enc, uint16_t tag, const char* str);

/**
 * @brief Encode raw byte array
 * 
 * @param enc Encoder instance
 * @param tag Field tag
 * @param data Byte array
 * @param len Length in bytes
 * @return DISTRIC_OK on success
 */
distric_err_t tlv_encode_bytes(tlv_encoder_t* enc, uint16_t tag, const uint8_t* data, size_t len);

/**
 * @brief Encode raw TLV field (pre-encoded)
 * 
 * Useful for copying fields from one buffer to another.
 * 
 * @param enc Encoder instance
 * @param type Field type
 * @param tag Field tag
 * @param data Value data
 * @param len Length of value
 * @return DISTRIC_OK on success
 */
distric_err_t tlv_encode_raw(tlv_encoder_t* enc, tlv_type_t type, uint16_t tag, 
                             const uint8_t* data, size_t len);

/* ============================================================================
 * FINALIZATION
 * ========================================================================= */

/**
 * @brief Finalize encoding and get buffer
 * 
 * Returns pointer to internal buffer. The buffer remains valid until
 * encoder is freed or reset.
 * 
 * @param encoder Encoder instance
 * @param len_out Output: buffer length in bytes
 * @return Pointer to encoded buffer, or NULL on error
 */
uint8_t* tlv_encoder_finalize(tlv_encoder_t* encoder, size_t* len_out);

/**
 * @brief Finalize and detach buffer (caller owns memory)
 * 
 * Returns buffer and transfers ownership to caller.
 * Encoder is reset after this call.
 * 
 * @param encoder Encoder instance
 * @param len_out Output: buffer length in bytes
 * @return Pointer to buffer (caller must free()), or NULL on error
 */
uint8_t* tlv_encoder_detach(tlv_encoder_t* encoder, size_t* len_out);

/* ============================================================================
 * TLV DECODER
 * ========================================================================= */

/**
 * @brief TLV decoder state (opaque)
 */
typedef struct tlv_decoder tlv_decoder_t;

/**
 * @brief Create a new TLV decoder
 * 
 * Creates a decoder that reads from the given buffer.
 * The buffer must remain valid for the lifetime of the decoder.
 * 
 * @param buffer TLV-encoded buffer
 * @param length Buffer length in bytes
 * @return Decoder instance, or NULL on allocation failure
 */
tlv_decoder_t* tlv_decoder_create(const uint8_t* buffer, size_t length);

/**
 * @brief Free TLV decoder
 * 
 * Does NOT free the buffer (decoder does not own it).
 * 
 * @param decoder Decoder to free
 */
void tlv_decoder_free(tlv_decoder_t* decoder);

/**
 * @brief Get current decoder position
 * 
 * @param decoder Decoder instance
 * @return Byte offset in buffer
 */
size_t tlv_decoder_position(const tlv_decoder_t* decoder);

/**
 * @brief Check if decoder has more data
 * 
 * @param decoder Decoder instance
 * @return true if more fields available
 */
bool tlv_decoder_has_more(const tlv_decoder_t* decoder);

/**
 * @brief Reset decoder to beginning
 * 
 * @param decoder Decoder instance
 */
void tlv_decoder_reset(tlv_decoder_t* decoder);

/* ============================================================================
 * DECODING FUNCTIONS
 * ========================================================================= */

/**
 * @brief Decode next field
 * 
 * Advances decoder position to next field.
 * The field's value pointer is a direct pointer into the buffer (zero-copy).
 * 
 * @param decoder Decoder instance
 * @param field_out Output: decoded field
 * @return DISTRIC_OK if field decoded, DISTRIC_ERR_EOF if no more fields,
 *         other error codes on corruption
 */
distric_err_t tlv_decode_next(tlv_decoder_t* decoder, tlv_field_t* field_out);

/**
 * @brief Find field by tag (linear search from current position)
 * 
 * Searches forward from current position. Does not reset position on failure.
 * 
 * @param decoder Decoder instance
 * @param tag Tag to search for
 * @param field_out Output: decoded field if found
 * @return DISTRIC_OK if found, DISTRIC_ERR_NOT_FOUND if not found
 */
distric_err_t tlv_find_field(tlv_decoder_t* decoder, uint16_t tag, tlv_field_t* field_out);

/**
 * @brief Skip current field without decoding
 * 
 * Advances decoder position past the current field.
 * 
 * @param decoder Decoder instance
 * @return DISTRIC_OK on success
 */
distric_err_t tlv_skip_field(tlv_decoder_t* decoder);

/* ============================================================================
 * FIELD VALUE EXTRACTION
 * ========================================================================= */

/**
 * @brief Extract uint8 from field
 * 
 * @param field Field to extract from
 * @param value_out Output: extracted value
 * @return DISTRIC_OK on success, DISTRIC_ERR_TYPE_MISMATCH if wrong type
 */
distric_err_t tlv_field_get_uint8(const tlv_field_t* field, uint8_t* value_out);

/**
 * @brief Extract uint16 from field
 */
distric_err_t tlv_field_get_uint16(const tlv_field_t* field, uint16_t* value_out);

/**
 * @brief Extract uint32 from field
 */
distric_err_t tlv_field_get_uint32(const tlv_field_t* field, uint32_t* value_out);

/**
 * @brief Extract uint64 from field
 */
distric_err_t tlv_field_get_uint64(const tlv_field_t* field, uint64_t* value_out);

/**
 * @brief Extract int32 from field
 */
distric_err_t tlv_field_get_int32(const tlv_field_t* field, int32_t* value_out);

/**
 * @brief Extract int64 from field
 */
distric_err_t tlv_field_get_int64(const tlv_field_t* field, int64_t* value_out);

/**
 * @brief Extract bool from field
 */
distric_err_t tlv_field_get_bool(const tlv_field_t* field, bool* value_out);

/**
 * @brief Extract string from field
 * 
 * Returns pointer to null-terminated string in original buffer (zero-copy).
 * 
 * @param field Field to extract from
 * @return Pointer to string, or NULL if wrong type
 */
const char* tlv_field_get_string(const tlv_field_t* field);

/**
 * @brief Extract byte array from field
 * 
 * Returns pointer to data in original buffer (zero-copy).
 * 
 * @param field Field to extract from
 * @param len_out Output: length of byte array
 * @return Pointer to data, or NULL if wrong type
 */
const uint8_t* tlv_field_get_bytes(const tlv_field_t* field, size_t* len_out);

/* ============================================================================
 * CONVENIENCE EXTRACTORS (with default values)
 * ========================================================================= */

/**
 * @brief Extract uint32 with default value if type mismatch
 * 
 * Useful for optional fields or forward compatibility.
 */
uint32_t tlv_field_as_uint32(const tlv_field_t* field);

/**
 * @brief Extract uint64 with default value if type mismatch
 */
uint64_t tlv_field_as_uint64(const tlv_field_t* field);

/**
 * @brief Extract string with default value if type mismatch
 * 
 * @return String pointer or empty string if type mismatch
 */
const char* tlv_field_as_string(const tlv_field_t* field);

/* ============================================================================
 * VALIDATION
 * ========================================================================= */

/**
 * @brief Validate TLV buffer structure
 * 
 * Performs a full scan of the buffer to check for:
 * - Valid field headers
 * - Lengths within buffer bounds
 * - No truncated fields
 * 
 * @param buffer TLV-encoded buffer
 * @param length Buffer length
 * @return true if valid, false if corrupted
 */
bool tlv_validate_buffer(const uint8_t* buffer, size_t length);

/**
 * @brief Get type name as string
 * 
 * @param type TLV type
 * @return Type name (e.g., "UINT32", "STRING")
 */
const char* tlv_type_to_string(tlv_type_t type);

#ifdef __cplusplus
}
#endif

#endif /* DISTRIC_PROTOCOL_TLV_H */



//####################
// FILE: /src/binary.c
//####################

/**
 * @file binary.c
 * @brief Binary Protocol Header Implementation
 * 
 * Provides serialization, deserialization, and validation for the
 * fixed 32-byte message header with network byte order conversion.
 */

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif

#include "distric_protocol/binary.h"
#include "distric_protocol/crc32.h"
#include <string.h>
#include <time.h>
#include <stdatomic.h>
#include <arpa/inet.h>  /* htonl, htons, ntohl, ntohs */

/* ============================================================================
 * BYTE ORDER CONVERSION (for 64-bit values)
 * ========================================================================= */

/** Convert 64-bit host to network byte order */
static inline uint64_t htonll(uint64_t value) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return ((uint64_t)htonl((uint32_t)(value & 0xFFFFFFFF)) << 32) | 
           htonl((uint32_t)(value >> 32));
#else
    return value;
#endif
}

/** Convert 64-bit network to host byte order */
static inline uint64_t ntohll(uint64_t value) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return ((uint64_t)ntohl((uint32_t)(value & 0xFFFFFFFF)) << 32) | 
           ntohl((uint32_t)(value >> 32));
#else
    return value;
#endif
}

/* ============================================================================
 * MESSAGE ID GENERATION
 * ========================================================================= */

/** Atomic counter for message ID generation */
static _Atomic uint64_t message_id_counter = 0;

/**
 * @brief Generate unique message ID
 * 
 * Combines timestamp (upper 32 bits) with atomic counter (lower 32 bits)
 * to ensure uniqueness even across restarts.
 */
static uint64_t generate_message_id(void) {
    uint64_t timestamp = (uint64_t)time(NULL);
    uint64_t counter = atomic_fetch_add(&message_id_counter, 1);
    
    /* Combine: [timestamp:32][counter:32] */
    return (timestamp << 32) | (counter & 0xFFFFFFFF);
}

/* ============================================================================
 * HEADER INITIALIZATION
 * ========================================================================= */

distric_err_t message_header_init(
    message_header_t* header,
    message_type_t msg_type,
    uint32_t payload_len
) {
    if (!header) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    memset(header, 0, sizeof(message_header_t));
    
    header->magic = PROTOCOL_MAGIC;
    header->version = PROTOCOL_VERSION;
    header->msg_type = msg_type;
    header->flags = MSG_FLAG_NONE;
    header->reserved = 0;
    header->payload_len = payload_len;
    header->message_id = generate_message_id();
    header->timestamp = (uint32_t)time(NULL);
    header->crc32 = 0;  /* Computed separately */
    
    return DISTRIC_OK;
}

/* ============================================================================
 * SERIALIZATION / DESERIALIZATION
 * ========================================================================= */

distric_err_t serialize_header(
    const message_header_t* header,
    uint8_t* buffer
) {
    if (!header || !buffer) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Convert to network byte order and write to buffer */
    uint32_t* buf32 = (uint32_t*)buffer;
    uint16_t* buf16 = (uint16_t*)buffer;
    uint64_t* buf64 = (uint64_t*)buffer;
    
    /* Offset 0: magic (4 bytes) */
    buf32[0] = htonl(header->magic);
    
    /* Offset 4: version (2 bytes) */
    buf16[2] = htons(header->version);
    
    /* Offset 6: msg_type (2 bytes) */
    buf16[3] = htons(header->msg_type);
    
    /* Offset 8: flags (2 bytes) */
    buf16[4] = htons(header->flags);
    
    /* Offset 10: reserved (2 bytes) */
    buf16[5] = htons(header->reserved);
    
    /* Offset 12: payload_len (4 bytes) */
    buf32[3] = htonl(header->payload_len);
    
    /* Offset 16: message_id (8 bytes) */
    buf64[2] = htonll(header->message_id);
    
    /* Offset 24: timestamp (4 bytes) */
    buf32[6] = htonl(header->timestamp);
    
    /* Offset 28: crc32 (4 bytes) */
    buf32[7] = htonl(header->crc32);
    
    return DISTRIC_OK;
}

distric_err_t deserialize_header(
    const uint8_t* buffer,
    message_header_t* header
) {
    if (!buffer || !header) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Convert from network byte order */
    const uint32_t* buf32 = (const uint32_t*)buffer;
    const uint16_t* buf16 = (const uint16_t*)buffer;
    const uint64_t* buf64 = (const uint64_t*)buffer;
    
    header->magic = ntohl(buf32[0]);
    header->version = ntohs(buf16[2]);
    header->msg_type = ntohs(buf16[3]);
    header->flags = ntohs(buf16[4]);
    header->reserved = ntohs(buf16[5]);
    header->payload_len = ntohl(buf32[3]);
    header->message_id = ntohll(buf64[2]);
    header->timestamp = ntohl(buf32[6]);
    header->crc32 = ntohl(buf32[7]);
    
    return DISTRIC_OK;
}

/* ============================================================================
 * VALIDATION
 * ========================================================================= */

bool validate_message_header(const message_header_t* header) {
    if (!header) {
        return false;
    }
    
    /* Check magic number */
    if (header->magic != PROTOCOL_MAGIC) {
        return false;
    }
    
    /* Check version (currently only support 0x0001) */
    if (header->version != PROTOCOL_VERSION) {
        return false;
    }
    
    /* Check message type is in valid range */
    if (header->msg_type == 0 || header->msg_type > 0x4FFF) {
        return false;
    }
    
    /* Check payload length is reasonable (max 10MB) */
    if (header->payload_len > 10 * 1024 * 1024) {
        return false;
    }
    
    /* Reserved field must be zero */
    if (header->reserved != 0) {
        return false;
    }
    
    return true;
}

/* ============================================================================
 * CRC32 COMPUTATION
 * ========================================================================= */

distric_err_t compute_header_crc32(
    message_header_t* header,
    const uint8_t* payload,
    size_t payload_len
) {
    if (!header) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Validate payload_len matches header */
    if (payload_len != header->payload_len) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Zero out CRC field before computation */
    uint32_t saved_crc = header->crc32;
    header->crc32 = 0;
    
    /* Serialize header to buffer */
    uint8_t header_buf[MESSAGE_HEADER_SIZE];
    distric_err_t err = serialize_header(header, header_buf);
    if (err != DISTRIC_OK) {
        header->crc32 = saved_crc;
        return err;
    }
    
    /* Compute CRC over header */
    uint32_t crc = 0xFFFFFFFF;
    crc = compute_crc32_incremental(header_buf, MESSAGE_HEADER_SIZE, crc);
    
    /* Compute CRC over payload if present */
    if (payload && payload_len > 0) {
        crc = compute_crc32_incremental(payload, payload_len, crc);
    }
    
    /* Final inversion */
    crc = ~crc;
    
    /* Store CRC in header */
    header->crc32 = crc;
    
    return DISTRIC_OK;
}

bool verify_message_crc32(
    const message_header_t* header,
    const uint8_t* payload,
    size_t payload_len
) {
    if (!header) {
        return false;
    }
    
    /* Make a copy to compute CRC */
    message_header_t temp = *header;
    uint32_t original_crc = temp.crc32;
    
    /* Recompute CRC */
    distric_err_t err = compute_header_crc32(&temp, payload, payload_len);
    if (err != DISTRIC_OK) {
        return false;
    }
    
    /* Compare */
    return temp.crc32 == original_crc;
}

/* ============================================================================
 * MESSAGE TYPE TO STRING
 * ========================================================================= */

const char* message_type_to_string(message_type_t msg_type) {
    switch (msg_type) {
        /* Raft messages */
        case MSG_RAFT_REQUEST_VOTE:
            return "RAFT_REQUEST_VOTE";
        case MSG_RAFT_REQUEST_VOTE_RESPONSE:
            return "RAFT_REQUEST_VOTE_RESPONSE";
        case MSG_RAFT_APPEND_ENTRIES:
            return "RAFT_APPEND_ENTRIES";
        case MSG_RAFT_APPEND_ENTRIES_RESPONSE:
            return "RAFT_APPEND_ENTRIES_RESPONSE";
        case MSG_RAFT_INSTALL_SNAPSHOT:
            return "RAFT_INSTALL_SNAPSHOT";
        case MSG_RAFT_INSTALL_SNAPSHOT_RESPONSE:
            return "RAFT_INSTALL_SNAPSHOT_RESPONSE";
        
        /* Gossip messages */
        case MSG_GOSSIP_PING:
            return "GOSSIP_PING";
        case MSG_GOSSIP_ACK:
            return "GOSSIP_ACK";
        case MSG_GOSSIP_INDIRECT_PING:
            return "GOSSIP_INDIRECT_PING";
        case MSG_GOSSIP_MEMBERSHIP_UPDATE:
            return "GOSSIP_MEMBERSHIP_UPDATE";
        case MSG_GOSSIP_SUSPECT:
            return "GOSSIP_SUSPECT";
        case MSG_GOSSIP_ALIVE:
            return "GOSSIP_ALIVE";
        
        /* Task messages */
        case MSG_TASK_ASSIGNMENT:
            return "TASK_ASSIGNMENT";
        case MSG_TASK_RESULT:
            return "TASK_RESULT";
        case MSG_TASK_STATUS:
            return "TASK_STATUS";
        case MSG_TASK_CANCEL:
            return "TASK_CANCEL";
        case MSG_TASK_HEARTBEAT:
            return "TASK_HEARTBEAT";
        
        /* Client messages */
        case MSG_CLIENT_SUBMIT:
            return "CLIENT_SUBMIT";
        case MSG_CLIENT_RESPONSE:
            return "CLIENT_RESPONSE";
        case MSG_CLIENT_QUERY:
            return "CLIENT_QUERY";
        case MSG_CLIENT_ERROR:
            return "CLIENT_ERROR";
        
        default:
            return "UNKNOWN";
    }
}



//####################
// FILE: /src/crc32.c
//####################

/**
 * @file crc32.c
 * @brief CRC32 Checksum Implementation
 * 
 * Table-based CRC32 using IEEE 802.3 polynomial (0xEDB88320 reversed).
 */

#include "distric_protocol/crc32.h"
#include <stdatomic.h>
#include <stdbool.h>

/* ============================================================================
 * CRC32 LOOKUP TABLE
 * ========================================================================= */

/** CRC32 lookup table (256 entries) */
static uint32_t crc32_table[256];

/** Table initialization flag */
static _Atomic bool table_initialized = false;

/**
 * @brief Initialize CRC32 lookup table
 * 
 * Uses IEEE 802.3 polynomial: 0xEDB88320 (reversed 0x04C11DB7)
 */
void crc32_init_table(void) {
    /* Check if already initialized (avoid redundant work) */
    if (atomic_load_explicit(&table_initialized, memory_order_acquire)) {
        return;
    }
    
    /* Generate lookup table */
    for (uint32_t i = 0; i < 256; i++) {
        uint32_t crc = i;
        for (uint32_t j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;
            } else {
                crc = crc >> 1;
            }
        }
        crc32_table[i] = crc;
    }
    
    /* Mark as initialized */
    atomic_store_explicit(&table_initialized, true, memory_order_release);
}

/* ============================================================================
 * CRC32 COMPUTATION
 * ========================================================================= */

/**
 * @brief Compute CRC32 with initial value
 */
uint32_t compute_crc32_incremental(const void* data, size_t len, uint32_t crc) {
    if (!data || len == 0) {
        return crc;
    }
    
    /* Ensure table is initialized */
    if (!atomic_load_explicit(&table_initialized, memory_order_acquire)) {
        crc32_init_table();
    }
    
    const uint8_t* ptr = (const uint8_t*)data;
    
    /* Process each byte */
    for (size_t i = 0; i < len; i++) {
        uint8_t index = (crc ^ ptr[i]) & 0xFF;
        crc = (crc >> 8) ^ crc32_table[index];
    }
    
    return crc;
}

/**
 * @brief Compute CRC32 checksum over data
 */
uint32_t compute_crc32(const void* data, size_t len) {
    if (!data || len == 0) {
        return 0;
    }
    
    /* Start with inverted initial value */
    uint32_t crc = 0xFFFFFFFF;
    
    /* Compute CRC */
    crc = compute_crc32_incremental(data, len, crc);
    
    /* Final inversion */
    return ~crc;
}



//####################
// FILE: /src/messages.c
//####################

/**
 * @file messages.c
 * @brief Protocol Message Serialization/Deserialization Implementation
 * 
 * Implements serialization and deserialization for all protocol messages
 * using the TLV encoding system.
 */

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif

#include "distric_protocol/messages.h"
#include <stdlib.h>
#include <string.h>

/* ============================================================================
 * RAFT MESSAGE SERIALIZATION - RequestVote
 * ========================================================================= */

distric_err_t serialize_raft_request_vote(
    const raft_request_vote_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(256);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    /* Encode fields */
    distric_err_t err;
    
    err = tlv_encode_uint32(enc, FIELD_TERM, msg->term);
    if (err != DISTRIC_OK) {
        tlv_encoder_free(enc);
        return err;
    }
    
    err = tlv_encode_string(enc, FIELD_CANDIDATE_ID, msg->candidate_id);
    if (err != DISTRIC_OK) {
        tlv_encoder_free(enc);
        return err;
    }
    
    err = tlv_encode_uint32(enc, FIELD_LAST_LOG_INDEX, msg->last_log_index);
    if (err != DISTRIC_OK) {
        tlv_encoder_free(enc);
        return err;
    }
    
    err = tlv_encode_uint32(enc, FIELD_LAST_LOG_TERM, msg->last_log_term);
    if (err != DISTRIC_OK) {
        tlv_encoder_free(enc);
        return err;
    }
    
    /* Finalize and detach buffer */
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_raft_request_vote(
    const uint8_t* buffer,
    size_t len,
    raft_request_vote_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Validate buffer */
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    /* Initialize message */
    memset(msg_out, 0, sizeof(raft_request_vote_t));
    
    /* Decode fields */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_TERM:
                tlv_field_get_uint32(&field, &msg_out->term);
                break;
            
            case FIELD_CANDIDATE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->candidate_id, str, sizeof(msg_out->candidate_id) - 1);
                }
                break;
            }
            
            case FIELD_LAST_LOG_INDEX:
                tlv_field_get_uint32(&field, &msg_out->last_log_index);
                break;
            
            case FIELD_LAST_LOG_TERM:
                tlv_field_get_uint32(&field, &msg_out->last_log_term);
                break;
            
            default:
                /* Unknown field - skip (forward compatibility) */
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

/* ============================================================================
 * RAFT MESSAGE SERIALIZATION - RequestVote Response
 * ========================================================================= */

distric_err_t serialize_raft_request_vote_response(
    const raft_request_vote_response_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(128);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_uint32(enc, FIELD_TERM, msg->term);
    tlv_encode_bool(enc, FIELD_VOTE_GRANTED, msg->vote_granted);
    tlv_encode_string(enc, FIELD_NODE_ID, msg->node_id);
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_raft_request_vote_response(
    const uint8_t* buffer,
    size_t len,
    raft_request_vote_response_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(raft_request_vote_response_t));
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_TERM:
                tlv_field_get_uint32(&field, &msg_out->term);
                break;
            
            case FIELD_VOTE_GRANTED:
                tlv_field_get_bool(&field, &msg_out->vote_granted);
                break;
            
            case FIELD_NODE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->node_id, str, sizeof(msg_out->node_id) - 1);
                }
                break;
            }
            
            default:
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

/* ============================================================================
 * RAFT MESSAGE SERIALIZATION - AppendEntries
 * ========================================================================= */

distric_err_t serialize_raft_append_entries(
    const raft_append_entries_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(1024);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    /* Encode basic fields */
    tlv_encode_uint32(enc, FIELD_TERM, msg->term);
    tlv_encode_string(enc, FIELD_LEADER_ID, msg->leader_id);
    tlv_encode_uint32(enc, FIELD_PREV_LOG_INDEX, msg->prev_log_index);
    tlv_encode_uint32(enc, FIELD_PREV_LOG_TERM, msg->prev_log_term);
    tlv_encode_uint32(enc, FIELD_LEADER_COMMIT, msg->leader_commit);
    
    /* Encode log entries (if any) */
    if (msg->entries && msg->entry_count > 0) {
        /* For simplicity, encode each entry as nested TLV */
        for (size_t i = 0; i < msg->entry_count; i++) {
            const raft_log_entry_t* entry = &msg->entries[i];
            
            /* Create sub-encoder for entry */
            tlv_encoder_t* entry_enc = tlv_encoder_create(256);
            tlv_encode_uint32(entry_enc, FIELD_ENTRY_INDEX, entry->index);
            tlv_encode_uint32(entry_enc, FIELD_ENTRY_TERM, entry->term);
            if (entry->data && entry->data_len > 0) {
                tlv_encode_bytes(entry_enc, FIELD_ENTRY_DATA, entry->data, entry->data_len);
            }
            
            /* Get encoded entry */
            size_t entry_len;
            uint8_t* entry_buf = tlv_encoder_finalize(entry_enc, &entry_len);
            
            /* Add as bytes field */
            tlv_encode_bytes(enc, FIELD_ENTRIES, entry_buf, entry_len);
            
            tlv_encoder_free(entry_enc);
        }
    }
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_raft_append_entries(
    const uint8_t* buffer,
    size_t len,
    raft_append_entries_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(raft_append_entries_t));
    
    /* Temporary storage for entries */
    raft_log_entry_t* entries = NULL;
    size_t entry_count = 0;
    size_t entry_capacity = 0;
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_TERM:
                tlv_field_get_uint32(&field, &msg_out->term);
                break;
            
            case FIELD_LEADER_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->leader_id, str, sizeof(msg_out->leader_id) - 1);
                }
                break;
            }
            
            case FIELD_PREV_LOG_INDEX:
                tlv_field_get_uint32(&field, &msg_out->prev_log_index);
                break;
            
            case FIELD_PREV_LOG_TERM:
                tlv_field_get_uint32(&field, &msg_out->prev_log_term);
                break;
            
            case FIELD_LEADER_COMMIT:
                tlv_field_get_uint32(&field, &msg_out->leader_commit);
                break;
            
            case FIELD_ENTRIES: {
                /* Decode nested entry */
                size_t entry_data_len;
                const uint8_t* entry_data = tlv_field_get_bytes(&field, &entry_data_len);
                
                if (entry_data) {
                    /* Grow array if needed */
                    if (entry_count >= entry_capacity) {
                        entry_capacity = entry_capacity == 0 ? 4 : entry_capacity * 2;
                        raft_log_entry_t* new_entries = (raft_log_entry_t*)realloc(
                            entries, entry_capacity * sizeof(raft_log_entry_t));
                        if (!new_entries) {
                            free(entries);
                            tlv_decoder_free(dec);
                            return DISTRIC_ERR_NO_MEMORY;
                        }
                        entries = new_entries;
                    }
                    
                    /* Decode entry fields */
                    raft_log_entry_t* entry = &entries[entry_count];
                    memset(entry, 0, sizeof(raft_log_entry_t));
                    
                    tlv_decoder_t* entry_dec = tlv_decoder_create(entry_data, entry_data_len);
                    tlv_field_t entry_field;
                    
                    while (tlv_decode_next(entry_dec, &entry_field) == DISTRIC_OK) {
                        switch (entry_field.tag) {
                            case FIELD_ENTRY_INDEX:
                                tlv_field_get_uint32(&entry_field, &entry->index);
                                break;
                            
                            case FIELD_ENTRY_TERM:
                                tlv_field_get_uint32(&entry_field, &entry->term);
                                break;
                            
                            case FIELD_ENTRY_DATA: {
                                size_t data_len;
                                const uint8_t* data = tlv_field_get_bytes(&entry_field, &data_len);
                                if (data && data_len > 0) {
                                    entry->data = (uint8_t*)malloc(data_len);
                                    if (entry->data) {
                                        memcpy(entry->data, data, data_len);
                                        entry->data_len = data_len;
                                    }
                                }
                                break;
                            }
                        }
                    }
                    
                    tlv_decoder_free(entry_dec);
                    entry_count++;
                }
                break;
            }
            
            default:
                break;
        }
    }
    
    msg_out->entries = entries;
    msg_out->entry_count = entry_count;
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

void free_raft_append_entries(raft_append_entries_t* msg) {
    if (!msg) {
        return;
    }
    
    if (msg->entries) {
        for (size_t i = 0; i < msg->entry_count; i++) {
            free(msg->entries[i].data);
        }
        free(msg->entries);
        msg->entries = NULL;
    }
    
    msg->entry_count = 0;
}

/* ============================================================================
 * RAFT MESSAGE SERIALIZATION - AppendEntries Response
 * ========================================================================= */

distric_err_t serialize_raft_append_entries_response(
    const raft_append_entries_response_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(128);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_uint32(enc, FIELD_TERM, msg->term);
    tlv_encode_bool(enc, FIELD_SUCCESS, msg->success);
    tlv_encode_string(enc, FIELD_NODE_ID, msg->node_id);
    tlv_encode_uint32(enc, FIELD_LAST_LOG_INDEX, msg->last_log_index);
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_raft_append_entries_response(
    const uint8_t* buffer,
    size_t len,
    raft_append_entries_response_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(raft_append_entries_response_t));
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_TERM:
                tlv_field_get_uint32(&field, &msg_out->term);
                break;
            
            case FIELD_SUCCESS:
                tlv_field_get_bool(&field, &msg_out->success);
                break;
            
            case FIELD_NODE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->node_id, str, sizeof(msg_out->node_id) - 1);
                }
                break;
            }
            
            case FIELD_LAST_LOG_INDEX:
                tlv_field_get_uint32(&field, &msg_out->last_log_index);
                break;
            
            default:
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

/* ============================================================================
 * GOSSIP MESSAGE SERIALIZATION - Ping
 * ========================================================================= */

distric_err_t serialize_gossip_ping(
    const gossip_ping_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(128);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_string(enc, FIELD_NODE_ID, msg->sender_id);
    tlv_encode_uint64(enc, FIELD_INCARNATION, msg->incarnation);
    tlv_encode_uint32(enc, FIELD_SEQUENCE_NUMBER, msg->sequence_number);
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_gossip_ping(
    const uint8_t* buffer,
    size_t len,
    gossip_ping_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(gossip_ping_t));
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_NODE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->sender_id, str, sizeof(msg_out->sender_id) - 1);
                }
                break;
            }
            
            case FIELD_INCARNATION:
                tlv_field_get_uint64(&field, &msg_out->incarnation);
                break;
            
            case FIELD_SEQUENCE_NUMBER:
                tlv_field_get_uint32(&field, &msg_out->sequence_number);
                break;
            
            default:
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

/* ============================================================================
 * GOSSIP MESSAGE SERIALIZATION - Ack
 * ========================================================================= */

distric_err_t serialize_gossip_ack(
    const gossip_ack_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(128);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_string(enc, FIELD_NODE_ID, msg->sender_id);
    tlv_encode_uint64(enc, FIELD_INCARNATION, msg->incarnation);
    tlv_encode_uint32(enc, FIELD_SEQUENCE_NUMBER, msg->sequence_number);
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_gossip_ack(
    const uint8_t* buffer,
    size_t len,
    gossip_ack_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(gossip_ack_t));
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_NODE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->sender_id, str, sizeof(msg_out->sender_id) - 1);
                }
                break;
            }
            
            case FIELD_INCARNATION:
                tlv_field_get_uint64(&field, &msg_out->incarnation);
                break;
            
            case FIELD_SEQUENCE_NUMBER:
                tlv_field_get_uint32(&field, &msg_out->sequence_number);
                break;
            
            default:
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

/* ============================================================================
 * GOSSIP MESSAGE SERIALIZATION - Membership Update
 * ========================================================================= */

distric_err_t serialize_gossip_membership_update(
    const gossip_membership_update_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(1024);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_string(enc, FIELD_NODE_ID, msg->sender_id);
    
    /* Encode each node update */
    if (msg->updates && msg->update_count > 0) {
        for (size_t i = 0; i < msg->update_count; i++) {
            const gossip_node_info_t* node = &msg->updates[i];
            
            /* Create sub-encoder for node info */
            tlv_encoder_t* node_enc = tlv_encoder_create(256);
            tlv_encode_string(node_enc, FIELD_NODE_ID, node->node_id);
            tlv_encode_string(node_enc, FIELD_NODE_ADDRESS, node->address);
            tlv_encode_uint16(node_enc, FIELD_NODE_PORT, node->port);
            tlv_encode_uint32(node_enc, FIELD_NODE_STATE, (uint32_t)node->state);
            tlv_encode_uint32(node_enc, FIELD_NODE_ROLE, (uint32_t)node->role);
            tlv_encode_uint64(node_enc, FIELD_INCARNATION, node->incarnation);
            
            size_t node_len;
            uint8_t* node_buf = tlv_encoder_finalize(node_enc, &node_len);
            
            tlv_encode_bytes(enc, FIELD_MEMBERSHIP_UPDATES, node_buf, node_len);
            
            tlv_encoder_free(node_enc);
        }
    }
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_gossip_membership_update(
    const uint8_t* buffer,
    size_t len,
    gossip_membership_update_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(gossip_membership_update_t));
    
    gossip_node_info_t* updates = NULL;
    size_t update_count = 0;
    size_t update_capacity = 0;
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_NODE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->sender_id, str, sizeof(msg_out->sender_id) - 1);
                }
                break;
            }
            
            case FIELD_MEMBERSHIP_UPDATES: {
                size_t node_data_len;
                const uint8_t* node_data = tlv_field_get_bytes(&field, &node_data_len);
                
                if (node_data) {
                    /* Grow array if needed */
                    if (update_count >= update_capacity) {
                        update_capacity = update_capacity == 0 ? 4 : update_capacity * 2;
                        gossip_node_info_t* new_updates = (gossip_node_info_t*)realloc(
                            updates, update_capacity * sizeof(gossip_node_info_t));
                        if (!new_updates) {
                            free(updates);
                            tlv_decoder_free(dec);
                            return DISTRIC_ERR_NO_MEMORY;
                        }
                        updates = new_updates;
                    }
                    
                    gossip_node_info_t* node = &updates[update_count];
                    memset(node, 0, sizeof(gossip_node_info_t));
                    
                    /* Decode node fields */
                    tlv_decoder_t* node_dec = tlv_decoder_create(node_data, node_data_len);
                    tlv_field_t node_field;
                    
                    while (tlv_decode_next(node_dec, &node_field) == DISTRIC_OK) {
                        switch (node_field.tag) {
                            case FIELD_NODE_ID: {
                                const char* str = tlv_field_get_string(&node_field);
                                if (str) {
                                    strncpy(node->node_id, str, sizeof(node->node_id) - 1);
                                }
                                break;
                            }
                            
                            case FIELD_NODE_ADDRESS: {
                                const char* str = tlv_field_get_string(&node_field);
                                if (str) {
                                    strncpy(node->address, str, sizeof(node->address) - 1);
                                }
                                break;
                            }
                            
                            case FIELD_NODE_PORT:
                                tlv_field_get_uint16(&node_field, &node->port);
                                break;
                            
                            case FIELD_NODE_STATE: {
                                uint32_t state;
                                tlv_field_get_uint32(&node_field, &state);
                                node->state = (node_state_t)state;
                                break;
                            }
                            
                            case FIELD_NODE_ROLE: {
                                uint32_t role;
                                tlv_field_get_uint32(&node_field, &role);
                                node->role = (node_role_t)role;
                                break;
                            }
                            
                            case FIELD_INCARNATION:
                                tlv_field_get_uint64(&node_field, &node->incarnation);
                                break;
                        }
                    }
                    
                    tlv_decoder_free(node_dec);
                    update_count++;
                }
                break;
            }
            
            default:
                break;
        }
    }
    
    msg_out->updates = updates;
    msg_out->update_count = update_count;
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

void free_gossip_membership_update(gossip_membership_update_t* msg) {
    if (!msg) {
        return;
    }
    
    free(msg->updates);
    msg->updates = NULL;
    msg->update_count = 0;
}
/**
 * @file messages_part2.c
 * @brief Task and Client Message Serialization (Part 2)
 * 
 * This file will be appended to messages.c during build.
 */

/* ============================================================================
 * TASK MESSAGE SERIALIZATION - Assignment
 * ========================================================================= */

distric_err_t serialize_task_assignment(
    const task_assignment_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(1024);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_string(enc, FIELD_TASK_ID, msg->task_id);
    tlv_encode_string(enc, FIELD_WORKFLOW_ID, msg->workflow_id);
    tlv_encode_string(enc, FIELD_TASK_TYPE, msg->task_type);
    
    if (msg->config_json) {
        tlv_encode_string(enc, FIELD_TASK_CONFIG, msg->config_json);
    }
    
    if (msg->input_data && msg->input_data_len > 0) {
        tlv_encode_bytes(enc, FIELD_TASK_INPUT, msg->input_data, msg->input_data_len);
    }
    
    tlv_encode_uint32(enc, FIELD_TIMEOUT_SEC, msg->timeout_sec);
    tlv_encode_uint32(enc, FIELD_RETRY_COUNT, msg->retry_count);
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_task_assignment(
    const uint8_t* buffer,
    size_t len,
    task_assignment_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(task_assignment_t));
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_TASK_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->task_id, str, sizeof(msg_out->task_id) - 1);
                }
                break;
            }
            
            case FIELD_WORKFLOW_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->workflow_id, str, sizeof(msg_out->workflow_id) - 1);
                }
                break;
            }
            
            case FIELD_TASK_TYPE: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->task_type, str, sizeof(msg_out->task_type) - 1);
                }
                break;
            }
            
            case FIELD_TASK_CONFIG: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    msg_out->config_json = strdup(str);
                }
                break;
            }
            
            case FIELD_TASK_INPUT: {
                size_t data_len;
                const uint8_t* data = tlv_field_get_bytes(&field, &data_len);
                if (data && data_len > 0) {
                    msg_out->input_data = (uint8_t*)malloc(data_len);
                    if (msg_out->input_data) {
                        memcpy(msg_out->input_data, data, data_len);
                        msg_out->input_data_len = data_len;
                    }
                }
                break;
            }
            
            case FIELD_TIMEOUT_SEC:
                tlv_field_get_uint32(&field, &msg_out->timeout_sec);
                break;
            
            case FIELD_RETRY_COUNT:
                tlv_field_get_uint32(&field, &msg_out->retry_count);
                break;
            
            default:
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

void free_task_assignment(task_assignment_t* msg) {
    if (!msg) {
        return;
    }
    
    free(msg->config_json);
    free(msg->input_data);
    
    msg->config_json = NULL;
    msg->input_data = NULL;
    msg->input_data_len = 0;
}

/* ============================================================================
 * TASK MESSAGE SERIALIZATION - Result
 * ========================================================================= */

distric_err_t serialize_task_result(
    const task_result_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(1024);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_string(enc, FIELD_TASK_ID, msg->task_id);
    tlv_encode_string(enc, FIELD_WORKER_ID, msg->worker_id);
    tlv_encode_uint32(enc, FIELD_TASK_STATUS, (uint32_t)msg->status);
    
    if (msg->output_data && msg->output_data_len > 0) {
        tlv_encode_bytes(enc, FIELD_TASK_OUTPUT, msg->output_data, msg->output_data_len);
    }
    
    if (msg->error_message) {
        tlv_encode_string(enc, FIELD_TASK_ERROR, msg->error_message);
    }
    
    tlv_encode_int32(enc, FIELD_EXIT_CODE, msg->exit_code);
    tlv_encode_uint64(enc, FIELD_STARTED_AT, msg->started_at);
    tlv_encode_uint64(enc, FIELD_COMPLETED_AT, msg->completed_at);
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_task_result(
    const uint8_t* buffer,
    size_t len,
    task_result_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(task_result_t));
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_TASK_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->task_id, str, sizeof(msg_out->task_id) - 1);
                }
                break;
            }
            
            case FIELD_WORKER_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->worker_id, str, sizeof(msg_out->worker_id) - 1);
                }
                break;
            }
            
            case FIELD_TASK_STATUS: {
                uint32_t status;
                tlv_field_get_uint32(&field, &status);
                msg_out->status = (task_status_t)status;
                break;
            }
            
            case FIELD_TASK_OUTPUT: {
                size_t data_len;
                const uint8_t* data = tlv_field_get_bytes(&field, &data_len);
                if (data && data_len > 0) {
                    msg_out->output_data = (uint8_t*)malloc(data_len);
                    if (msg_out->output_data) {
                        memcpy(msg_out->output_data, data, data_len);
                        msg_out->output_data_len = data_len;
                    }
                }
                break;
            }
            
            case FIELD_TASK_ERROR: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    msg_out->error_message = strdup(str);
                }
                break;
            }
            
            case FIELD_EXIT_CODE:
                tlv_field_get_int32(&field, &msg_out->exit_code);
                break;
            
            case FIELD_STARTED_AT:
                tlv_field_get_uint64(&field, &msg_out->started_at);
                break;
            
            case FIELD_COMPLETED_AT:
                tlv_field_get_uint64(&field, &msg_out->completed_at);
                break;
            
            default:
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

void free_task_result(task_result_t* msg) {
    if (!msg) {
        return;
    }
    
    free(msg->output_data);
    free(msg->error_message);
    
    msg->output_data = NULL;
    msg->error_message = NULL;
    msg->output_data_len = 0;
}

/* ============================================================================
 * CLIENT MESSAGE SERIALIZATION - Submit
 * ========================================================================= */

distric_err_t serialize_client_submit(
    const client_submit_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(512);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_string(enc, FIELD_MESSAGE_ID, msg->message_id);
    tlv_encode_string(enc, FIELD_EVENT_TYPE, msg->event_type);
    
    if (msg->payload_json) {
        tlv_encode_string(enc, FIELD_MESSAGE_PAYLOAD, msg->payload_json);
    }
    
    tlv_encode_uint64(enc, FIELD_TIMESTAMP, msg->timestamp);
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_client_submit(
    const uint8_t* buffer,
    size_t len,
    client_submit_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(client_submit_t));
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_MESSAGE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->message_id, str, sizeof(msg_out->message_id) - 1);
                }
                break;
            }
            
            case FIELD_EVENT_TYPE: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->event_type, str, sizeof(msg_out->event_type) - 1);
                }
                break;
            }
            
            case FIELD_MESSAGE_PAYLOAD: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    msg_out->payload_json = strdup(str);
                }
                break;
            }
            
            case FIELD_TIMESTAMP:
                tlv_field_get_uint64(&field, &msg_out->timestamp);
                break;
            
            default:
                break;
        }
    }
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

void free_client_submit(client_submit_t* msg) {
    if (!msg) {
        return;
    }
    
    free(msg->payload_json);
    msg->payload_json = NULL;
}

/* ============================================================================
 * CLIENT MESSAGE SERIALIZATION - Response
 * ========================================================================= */

distric_err_t serialize_client_response(
    const client_response_t* msg,
    uint8_t** buffer_out,
    size_t* len_out
) {
    if (!msg || !buffer_out || !len_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    tlv_encoder_t* enc = tlv_encoder_create(512);
    if (!enc) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_encode_string(enc, FIELD_MESSAGE_ID, msg->message_id);
    tlv_encode_uint32(enc, FIELD_RESPONSE_CODE, msg->response_code);
    
    if (msg->response_message) {
        tlv_encode_string(enc, FIELD_RESPONSE_MESSAGE, msg->response_message);
    }
    
    /* Encode workflows triggered as array */
    if (msg->workflows_triggered && msg->workflow_count > 0) {
        for (size_t i = 0; i < msg->workflow_count; i++) {
            if (msg->workflows_triggered[i]) {
                tlv_encode_string(enc, FIELD_WORKFLOWS_TRIGGERED, msg->workflows_triggered[i]);
            }
        }
    }
    
    *buffer_out = tlv_encoder_detach(enc, len_out);
    tlv_encoder_free(enc);
    
    return *buffer_out ? DISTRIC_OK : DISTRIC_ERR_NO_MEMORY;
}

distric_err_t deserialize_client_response(
    const uint8_t* buffer,
    size_t len,
    client_response_t* msg_out
) {
    if (!buffer || !msg_out || len == 0) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (!tlv_validate_buffer(buffer, len)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    memset(msg_out, 0, sizeof(client_response_t));
    
    char** workflows = NULL;
    size_t workflow_count = 0;
    size_t workflow_capacity = 0;
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    if (!dec) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    tlv_field_t field;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        switch (field.tag) {
            case FIELD_MESSAGE_ID: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    strncpy(msg_out->message_id, str, sizeof(msg_out->message_id) - 1);
                }
                break;
            }
            
            case FIELD_RESPONSE_CODE:
                tlv_field_get_uint32(&field, &msg_out->response_code);
                break;
            
            case FIELD_RESPONSE_MESSAGE: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    msg_out->response_message = strdup(str);
                }
                break;
            }
            
            case FIELD_WORKFLOWS_TRIGGERED: {
                const char* str = tlv_field_get_string(&field);
                if (str) {
                    /* Grow array if needed */
                    if (workflow_count >= workflow_capacity) {
                        workflow_capacity = workflow_capacity == 0 ? 4 : workflow_capacity * 2;
                        char** new_workflows = (char**)realloc(workflows, 
                                                               workflow_capacity * sizeof(char*));
                        if (!new_workflows) {
                            for (size_t i = 0; i < workflow_count; i++) {
                                free(workflows[i]);
                            }
                            free(workflows);
                            tlv_decoder_free(dec);
                            return DISTRIC_ERR_NO_MEMORY;
                        }
                        workflows = new_workflows;
                    }
                    
                    workflows[workflow_count++] = strdup(str);
                }
                break;
            }
            
            default:
                break;
        }
    }
    
    msg_out->workflows_triggered = workflows;
    msg_out->workflow_count = workflow_count;
    
    tlv_decoder_free(dec);
    return DISTRIC_OK;
}

void free_client_response(client_response_t* msg) {
    if (!msg) {
        return;
    }
    
    free(msg->response_message);
    
    if (msg->workflows_triggered) {
        for (size_t i = 0; i < msg->workflow_count; i++) {
            free(msg->workflows_triggered[i]);
        }
        free(msg->workflows_triggered);
    }
    
    msg->response_message = NULL;
    msg->workflows_triggered = NULL;
    msg->workflow_count = 0;
}

/* ============================================================================
 * UTILITY FUNCTIONS
 * ========================================================================= */

const char* node_state_to_string(node_state_t state) {
    switch (state) {
        case NODE_STATE_ALIVE:      return "ALIVE";
        case NODE_STATE_SUSPECTED:  return "SUSPECTED";
        case NODE_STATE_FAILED:     return "FAILED";
        case NODE_STATE_LEFT:       return "LEFT";
        default:                    return "UNKNOWN";
    }
}

const char* node_role_to_string(node_role_t role) {
    switch (role) {
        case NODE_ROLE_COORDINATOR: return "COORDINATOR";
        case NODE_ROLE_WORKER:      return "WORKER";
        default:                    return "UNKNOWN";
    }
}

const char* task_status_to_string(task_status_t status) {
    switch (status) {
        case TASK_STATUS_PENDING:   return "PENDING";
        case TASK_STATUS_RUNNING:   return "RUNNING";
        case TASK_STATUS_COMPLETED: return "COMPLETED";
        case TASK_STATUS_FAILED:    return "FAILED";
        case TASK_STATUS_TIMEOUT:   return "TIMEOUT";
        case TASK_STATUS_CANCELLED: return "CANCELLED";
        default:                    return "UNKNOWN";
    }
}



//####################
// FILE: /src/tlv.c
//####################

/**
 * @file tlv.c
 * @brief TLV Encoder/Decoder Implementation
 * 
 * Provides dynamic buffer management for encoding and zero-copy
 * decoding with forward compatibility (unknown fields can be skipped).
 */

#ifndef _POSIX_C_SOURCE
#define _POSIX_C_SOURCE 200112L
#endif

#include "distric_protocol/tlv.h"
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>  /* htonl, htons, ntohl, ntohs */

/* ============================================================================
 * BYTE ORDER CONVERSION (64-bit)
 * ========================================================================= */

static inline uint64_t htonll(uint64_t value) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return ((uint64_t)htonl((uint32_t)(value & 0xFFFFFFFF)) << 32) | 
           htonl((uint32_t)(value >> 32));
#else
    return value;
#endif
}

static inline uint64_t ntohll(uint64_t value) {
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    return ((uint64_t)ntohl((uint32_t)(value & 0xFFFFFFFF)) << 32) | 
           ntohl((uint32_t)(value >> 32));
#else
    return value;
#endif
}

/* ============================================================================
 * TLV FIELD HEADER
 * ========================================================================= */

/** Size of TLV field header: [type:1][tag:2][length:4] = 7 bytes */
#define TLV_HEADER_SIZE 7

/**
 * @brief Write TLV field header to buffer
 * 
 * @param buffer Output buffer (must have at least 7 bytes)
 * @param type Field type
 * @param tag Field tag
 * @param length Value length
 */
static inline void write_tlv_header(uint8_t* buffer, tlv_type_t type, 
                                    uint16_t tag, uint32_t length) {
    buffer[0] = (uint8_t)type;
    *(uint16_t*)(buffer + 1) = htons(tag);
    *(uint32_t*)(buffer + 3) = htonl(length);
}

/**
 * @brief Read TLV field header from buffer
 * 
 * @param buffer Input buffer
 * @param type_out Output: field type
 * @param tag_out Output: field tag
 * @param length_out Output: value length
 */
static inline void read_tlv_header(const uint8_t* buffer, tlv_type_t* type_out,
                                   uint16_t* tag_out, uint32_t* length_out) {
    *type_out = (tlv_type_t)buffer[0];
    *tag_out = ntohs(*(const uint16_t*)(buffer + 1));
    *length_out = ntohl(*(const uint32_t*)(buffer + 3));
}

/* ============================================================================
 * ENCODER IMPLEMENTATION
 * ========================================================================= */

struct tlv_encoder {
    uint8_t* buffer;
    size_t capacity;
    size_t offset;
};

tlv_encoder_t* tlv_encoder_create(size_t initial_capacity) {
    if (initial_capacity == 0) {
        initial_capacity = 256;
    }
    
    tlv_encoder_t* enc = (tlv_encoder_t*)malloc(sizeof(tlv_encoder_t));
    if (!enc) {
        return NULL;
    }
    
    enc->buffer = (uint8_t*)malloc(initial_capacity);
    if (!enc->buffer) {
        free(enc);
        return NULL;
    }
    
    enc->capacity = initial_capacity;
    enc->offset = 0;
    
    return enc;
}

void tlv_encoder_free(tlv_encoder_t* encoder) {
    if (!encoder) {
        return;
    }
    
    free(encoder->buffer);
    free(encoder);
}

size_t tlv_encoder_size(const tlv_encoder_t* encoder) {
    return encoder ? encoder->offset : 0;
}

void tlv_encoder_reset(tlv_encoder_t* encoder) {
    if (encoder) {
        encoder->offset = 0;
    }
}

/**
 * @brief Ensure encoder has enough capacity
 * 
 * Grows buffer if needed (doubles capacity).
 */
static distric_err_t ensure_capacity(tlv_encoder_t* enc, size_t required) {
    if (!enc) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (enc->offset + required <= enc->capacity) {
        return DISTRIC_OK;  /* Sufficient capacity */
    }
    
    /* Calculate new capacity (double until sufficient) */
    size_t new_capacity = enc->capacity;
    while (new_capacity < enc->offset + required) {
        new_capacity *= 2;
    }
    
    /* Reallocate buffer */
    uint8_t* new_buffer = (uint8_t*)realloc(enc->buffer, new_capacity);
    if (!new_buffer) {
        return DISTRIC_ERR_NO_MEMORY;
    }
    
    enc->buffer = new_buffer;
    enc->capacity = new_capacity;
    
    return DISTRIC_OK;
}

/* ============================================================================
 * RAW ENCODING (used by all type-specific encoders)
 * ========================================================================= */

distric_err_t tlv_encode_raw(tlv_encoder_t* enc, tlv_type_t type, uint16_t tag,
                             const uint8_t* data, size_t len) {
    if (!enc) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Ensure capacity for header + data */
    distric_err_t err = ensure_capacity(enc, TLV_HEADER_SIZE + len);
    if (err != DISTRIC_OK) {
        return err;
    }
    
    /* Write header */
    write_tlv_header(enc->buffer + enc->offset, type, tag, (uint32_t)len);
    enc->offset += TLV_HEADER_SIZE;
    
    /* Write data */
    if (data && len > 0) {
        memcpy(enc->buffer + enc->offset, data, len);
        enc->offset += len;
    }
    
    return DISTRIC_OK;
}

/* ============================================================================
 * TYPE-SPECIFIC ENCODING
 * ========================================================================= */

distric_err_t tlv_encode_uint8(tlv_encoder_t* enc, uint16_t tag, uint8_t value) {
    return tlv_encode_raw(enc, TLV_UINT8, tag, &value, sizeof(uint8_t));
}

distric_err_t tlv_encode_uint16(tlv_encoder_t* enc, uint16_t tag, uint16_t value) {
    uint16_t value_be = htons(value);
    return tlv_encode_raw(enc, TLV_UINT16, tag, (uint8_t*)&value_be, sizeof(uint16_t));
}

distric_err_t tlv_encode_uint32(tlv_encoder_t* enc, uint16_t tag, uint32_t value) {
    uint32_t value_be = htonl(value);
    return tlv_encode_raw(enc, TLV_UINT32, tag, (uint8_t*)&value_be, sizeof(uint32_t));
}

distric_err_t tlv_encode_uint64(tlv_encoder_t* enc, uint16_t tag, uint64_t value) {
    uint64_t value_be = htonll(value);
    return tlv_encode_raw(enc, TLV_UINT64, tag, (uint8_t*)&value_be, sizeof(uint64_t));
}

distric_err_t tlv_encode_int32(tlv_encoder_t* enc, uint16_t tag, int32_t value) {
    uint32_t value_be = htonl((uint32_t)value);
    return tlv_encode_raw(enc, TLV_INT32, tag, (uint8_t*)&value_be, sizeof(int32_t));
}

distric_err_t tlv_encode_int64(tlv_encoder_t* enc, uint16_t tag, int64_t value) {
    uint64_t value_be = htonll((uint64_t)value);
    return tlv_encode_raw(enc, TLV_INT64, tag, (uint8_t*)&value_be, sizeof(int64_t));
}

distric_err_t tlv_encode_bool(tlv_encoder_t* enc, uint16_t tag, bool value) {
    uint8_t val = value ? 1 : 0;
    return tlv_encode_raw(enc, TLV_BOOL, tag, &val, sizeof(uint8_t));
}

distric_err_t tlv_encode_string(tlv_encoder_t* enc, uint16_t tag, const char* str) {
    if (!str) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Include null terminator */
    size_t len = strlen(str) + 1;
    return tlv_encode_raw(enc, TLV_STRING, tag, (const uint8_t*)str, len);
}

distric_err_t tlv_encode_bytes(tlv_encoder_t* enc, uint16_t tag, 
                               const uint8_t* data, size_t len) {
    return tlv_encode_raw(enc, TLV_BYTES, tag, data, len);
}

/* ============================================================================
 * FINALIZATION
 * ========================================================================= */

uint8_t* tlv_encoder_finalize(tlv_encoder_t* encoder, size_t* len_out) {
    if (!encoder || !len_out) {
        return NULL;
    }
    
    *len_out = encoder->offset;
    return encoder->buffer;
}

uint8_t* tlv_encoder_detach(tlv_encoder_t* encoder, size_t* len_out) {
    if (!encoder || !len_out) {
        return NULL;
    }
    
    uint8_t* buffer = encoder->buffer;
    *len_out = encoder->offset;
    
    /* Reset encoder (buffer ownership transferred to caller) */
    encoder->buffer = NULL;
    encoder->capacity = 0;
    encoder->offset = 0;
    
    return buffer;
}

/* ============================================================================
 * DECODER IMPLEMENTATION
 * ========================================================================= */

struct tlv_decoder {
    const uint8_t* buffer;
    size_t length;
    size_t offset;
};

tlv_decoder_t* tlv_decoder_create(const uint8_t* buffer, size_t length) {
    if (!buffer || length == 0) {
        return NULL;
    }
    
    tlv_decoder_t* dec = (tlv_decoder_t*)malloc(sizeof(tlv_decoder_t));
    if (!dec) {
        return NULL;
    }
    
    dec->buffer = buffer;
    dec->length = length;
    dec->offset = 0;
    
    return dec;
}

void tlv_decoder_free(tlv_decoder_t* decoder) {
    free(decoder);
}

size_t tlv_decoder_position(const tlv_decoder_t* decoder) {
    return decoder ? decoder->offset : 0;
}

bool tlv_decoder_has_more(const tlv_decoder_t* decoder) {
    if (!decoder) {
        return false;
    }
    
    return decoder->offset < decoder->length;
}

void tlv_decoder_reset(tlv_decoder_t* decoder) {
    if (decoder) {
        decoder->offset = 0;
    }
}

/* ============================================================================
 * DECODING
 * ========================================================================= */

distric_err_t tlv_decode_next(tlv_decoder_t* decoder, tlv_field_t* field_out) {
    if (!decoder || !field_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Check if we have enough bytes for header */
    if (decoder->offset + TLV_HEADER_SIZE > decoder->length) {
        return DISTRIC_ERR_EOF;
    }
    
    /* Read header */
    const uint8_t* header = decoder->buffer + decoder->offset;
    tlv_type_t type;
    uint16_t tag;
    uint32_t length;
    
    read_tlv_header(header, &type, &tag, &length);
    
    /* Advance past header */
    decoder->offset += TLV_HEADER_SIZE;
    
    /* Check if we have enough bytes for value */
    if (decoder->offset + length > decoder->length) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    /* Fill output field (zero-copy: points into original buffer) */
    field_out->type = type;
    field_out->tag = tag;
    field_out->length = length;
    field_out->value = decoder->buffer + decoder->offset;
    
    /* Advance past value */
    decoder->offset += length;
    
    return DISTRIC_OK;
}

distric_err_t tlv_find_field(tlv_decoder_t* decoder, uint16_t tag, 
                             tlv_field_t* field_out) {
    if (!decoder || !field_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Linear search from current position */
    while (tlv_decoder_has_more(decoder)) {
        size_t saved_offset = decoder->offset;
        
        distric_err_t err = tlv_decode_next(decoder, field_out);
        if (err != DISTRIC_OK) {
            return err;
        }
        
        if (field_out->tag == tag) {
            /* Found! Rewind to start of this field */
            decoder->offset = saved_offset;
            
            /* Decode again to set field_out correctly */
            return tlv_decode_next(decoder, field_out);
        }
    }
    
    return DISTRIC_ERR_NOT_FOUND;
}

distric_err_t tlv_skip_field(tlv_decoder_t* decoder) {
    if (!decoder) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    /* Check if we have enough bytes for header */
    if (decoder->offset + TLV_HEADER_SIZE > decoder->length) {
        return DISTRIC_ERR_EOF;
    }
    
    /* Read header to get length */
    const uint8_t* header = decoder->buffer + decoder->offset;
    tlv_type_t type;
    uint16_t tag;
    uint32_t length;
    
    read_tlv_header(header, &type, &tag, &length);
    
    /* Skip header + value */
    decoder->offset += TLV_HEADER_SIZE + length;
    
    /* Check bounds */
    if (decoder->offset > decoder->length) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    return DISTRIC_OK;
}

/* ============================================================================
 * FIELD VALUE EXTRACTION (with type checking)
 * ========================================================================= */

distric_err_t tlv_field_get_uint8(const tlv_field_t* field, uint8_t* value_out) {
    if (!field || !value_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (field->type != TLV_UINT8) {
        return DISTRIC_ERR_TYPE_MISMATCH;
    }
    
    if (field->length != sizeof(uint8_t)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    *value_out = field->value[0];
    return DISTRIC_OK;
}

distric_err_t tlv_field_get_uint16(const tlv_field_t* field, uint16_t* value_out) {
    if (!field || !value_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (field->type != TLV_UINT16) {
        return DISTRIC_ERR_TYPE_MISMATCH;
    }
    
    if (field->length != sizeof(uint16_t)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    *value_out = ntohs(*(const uint16_t*)field->value);
    return DISTRIC_OK;
}

distric_err_t tlv_field_get_uint32(const tlv_field_t* field, uint32_t* value_out) {
    if (!field || !value_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (field->type != TLV_UINT32) {
        return DISTRIC_ERR_TYPE_MISMATCH;
    }
    
    if (field->length != sizeof(uint32_t)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    *value_out = ntohl(*(const uint32_t*)field->value);
    return DISTRIC_OK;
}

distric_err_t tlv_field_get_uint64(const tlv_field_t* field, uint64_t* value_out) {
    if (!field || !value_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (field->type != TLV_UINT64) {
        return DISTRIC_ERR_TYPE_MISMATCH;
    }
    
    if (field->length != sizeof(uint64_t)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    *value_out = ntohll(*(const uint64_t*)field->value);
    return DISTRIC_OK;
}

distric_err_t tlv_field_get_int32(const tlv_field_t* field, int32_t* value_out) {
    if (!field || !value_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (field->type != TLV_INT32) {
        return DISTRIC_ERR_TYPE_MISMATCH;
    }
    
    if (field->length != sizeof(int32_t)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    uint32_t temp = ntohl(*(const uint32_t*)field->value);
    *value_out = (int32_t)temp;
    return DISTRIC_OK;
}

distric_err_t tlv_field_get_int64(const tlv_field_t* field, int64_t* value_out) {
    if (!field || !value_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (field->type != TLV_INT64) {
        return DISTRIC_ERR_TYPE_MISMATCH;
    }
    
    if (field->length != sizeof(int64_t)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    uint64_t temp = ntohll(*(const uint64_t*)field->value);
    *value_out = (int64_t)temp;
    return DISTRIC_OK;
}

distric_err_t tlv_field_get_bool(const tlv_field_t* field, bool* value_out) {
    if (!field || !value_out) {
        return DISTRIC_ERR_INVALID_ARG;
    }
    
    if (field->type != TLV_BOOL) {
        return DISTRIC_ERR_TYPE_MISMATCH;
    }
    
    if (field->length != sizeof(uint8_t)) {
        return DISTRIC_ERR_INVALID_FORMAT;
    }
    
    *value_out = field->value[0] != 0;
    return DISTRIC_OK;
}

const char* tlv_field_get_string(const tlv_field_t* field) {
    if (!field || field->type != TLV_STRING || field->length == 0) {
        return NULL;
    }
    
    /* Verify null terminator is present */
    if (field->value[field->length - 1] != '\0') {
        return NULL;
    }
    
    return (const char*)field->value;
}

const uint8_t* tlv_field_get_bytes(const tlv_field_t* field, size_t* len_out) {
    if (!field || !len_out) {
        return NULL;
    }
    
    if (field->type != TLV_BYTES) {
        return NULL;
    }
    
    *len_out = field->length;
    return field->value;
}

/* ============================================================================
 * CONVENIENCE EXTRACTORS (with default values)
 * ========================================================================= */

uint32_t tlv_field_as_uint32(const tlv_field_t* field) {
    uint32_t value = 0;
    tlv_field_get_uint32(field, &value);
    return value;
}

uint64_t tlv_field_as_uint64(const tlv_field_t* field) {
    uint64_t value = 0;
    tlv_field_get_uint64(field, &value);
    return value;
}

const char* tlv_field_as_string(const tlv_field_t* field) {
    const char* str = tlv_field_get_string(field);
    return str ? str : "";
}

/* ============================================================================
 * VALIDATION
 * ========================================================================= */

bool tlv_validate_buffer(const uint8_t* buffer, size_t length) {
    if (!buffer || length == 0) {
        return false;
    }
    
    size_t offset = 0;
    
    while (offset < length) {
        /* Check header */
        if (offset + TLV_HEADER_SIZE > length) {
            return false;  /* Truncated header */
        }
        
        /* Read header */
        tlv_type_t type;
        uint16_t tag;
        uint32_t field_length;
        
        read_tlv_header(buffer + offset, &type, &tag, &field_length);
        offset += TLV_HEADER_SIZE;
        
        /* Check value length */
        if (offset + field_length > length) {
            return false;  /* Truncated value */
        }
        
        offset += field_length;
    }
    
    return offset == length;  /* Must consume entire buffer */
}

const char* tlv_type_to_string(tlv_type_t type) {
    switch (type) {
        case TLV_UINT8:     return "UINT8";
        case TLV_UINT16:    return "UINT16";
        case TLV_UINT32:    return "UINT32";
        case TLV_UINT64:    return "UINT64";
        case TLV_INT8:      return "INT8";
        case TLV_INT16:     return "INT16";
        case TLV_INT32:     return "INT32";
        case TLV_INT64:     return "INT64";
        case TLV_FLOAT:     return "FLOAT";
        case TLV_DOUBLE:    return "DOUBLE";
        case TLV_BOOL:      return "BOOL";
        case TLV_STRING:    return "STRING";
        case TLV_BYTES:     return "BYTES";
        case TLV_ARRAY:     return "ARRAY";
        case TLV_MAP:       return "MAP";
        default:            return "UNKNOWN";
    }
}



//####################
// FILE: /tests/CMakeLists.txt
//####################

# Test executables for distric_protocol

# Test: Binary Protocol
add_executable(test_binary test_binary.c)
target_link_libraries(test_binary distric_protocol distric_obs Threads::Threads)
add_test(NAME test_binary COMMAND test_binary)

# Test: TLV Encoder/Decoder
add_executable(test_tlv test_tlv.c)
target_link_libraries(test_tlv distric_protocol distric_obs Threads::Threads)
add_test(NAME test_tlv COMMAND test_tlv)

# Test: Message Serialization
add_executable(test_messages test_messages.c)
target_link_libraries(test_messages distric_protocol distric_obs Threads::Threads)
add_test(NAME test_messages COMMAND test_messages)



//####################
// FILE: /tests/test_binary.c
//####################

/**
 * @file test_binary.c
 * @brief Comprehensive tests for binary protocol header
 * 
 * Tests:
 * - Header initialization
 * - Serialization/deserialization
 * - Network byte order conversion
 * - CRC32 computation and verification
 * - Message validation
 * - Corruption detection
 */

#include <distric_protocol.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

static int tests_passed = 0;
static int tests_failed = 0;

#define TEST_START() printf("\n[TEST] %s...\n", __func__)
#define TEST_PASS() do { \
    printf("[PASS] %s\n", __func__); \
    tests_passed++; \
} while(0)

#define ASSERT_OK(expr) do { \
    distric_err_t _err = (expr); \
    if (_err != DISTRIC_OK) { \
        fprintf(stderr, "FAIL: %s returned %d\n", #expr, _err); \
        tests_failed++; \
        return; \
    } \
} while(0)

#define ASSERT_TRUE(expr) do { \
    if (!(expr)) { \
        fprintf(stderr, "FAIL: %s is false\n", #expr); \
        tests_failed++; \
        return; \
    } \
} while(0)

/* ============================================================================
 * TEST CASES
 * ========================================================================= */

void test_header_initialization() {
    TEST_START();
    
    message_header_t header;
    ASSERT_OK(message_header_init(&header, MSG_RAFT_REQUEST_VOTE, 1024));
    
    ASSERT_TRUE(header.magic == PROTOCOL_MAGIC);
    ASSERT_TRUE(header.version == PROTOCOL_VERSION);
    ASSERT_TRUE(header.msg_type == MSG_RAFT_REQUEST_VOTE);
    ASSERT_TRUE(header.flags == MSG_FLAG_NONE);
    ASSERT_TRUE(header.payload_len == 1024);
    ASSERT_TRUE(header.message_id != 0);
    ASSERT_TRUE(header.timestamp != 0);
    ASSERT_TRUE(header.reserved == 0);
    
    printf("  Magic: 0x%08X\n", header.magic);
    printf("  Version: 0x%04X\n", header.version);
    printf("  Message ID: %lu\n", header.message_id);
    printf("  Timestamp: %u\n", header.timestamp);
    
    TEST_PASS();
}

void test_unique_message_ids() {
    TEST_START();
    
    message_header_t headers[1000];
    
    /* Generate 1000 message IDs */
    for (int i = 0; i < 1000; i++) {
        ASSERT_OK(message_header_init(&headers[i], MSG_CLIENT_SUBMIT, 0));
    }
    
    /* Check all are unique */
    for (int i = 0; i < 999; i++) {
        for (int j = i + 1; j < 1000; j++) {
            ASSERT_TRUE(headers[i].message_id != headers[j].message_id);
        }
    }
    
    printf("  1000 unique message IDs generated\n");
    TEST_PASS();
}

void test_serialization_deserialization() {
    TEST_START();
    
    message_header_t original;
    ASSERT_OK(message_header_init(&original, MSG_GOSSIP_PING, 512));
    original.flags = MSG_FLAG_URGENT | MSG_FLAG_COMPRESSED;
    
    /* Serialize */
    uint8_t buffer[MESSAGE_HEADER_SIZE];
    ASSERT_OK(serialize_header(&original, buffer));
    
    /* Deserialize */
    message_header_t deserialized;
    ASSERT_OK(deserialize_header(buffer, &deserialized));
    
    /* Verify all fields match */
    ASSERT_TRUE(deserialized.magic == original.magic);
    ASSERT_TRUE(deserialized.version == original.version);
    ASSERT_TRUE(deserialized.msg_type == original.msg_type);
    ASSERT_TRUE(deserialized.flags == original.flags);
    ASSERT_TRUE(deserialized.payload_len == original.payload_len);
    ASSERT_TRUE(deserialized.message_id == original.message_id);
    ASSERT_TRUE(deserialized.timestamp == original.timestamp);
    ASSERT_TRUE(deserialized.crc32 == original.crc32);
    
    printf("  Round-trip serialization successful\n");
    TEST_PASS();
}

void test_network_byte_order() {
    TEST_START();
    
    message_header_t header;
    ASSERT_OK(message_header_init(&header, MSG_TASK_ASSIGNMENT, 0x12345678));
    header.message_id = 0x0102030405060708ULL;
    
    /* Serialize */
    uint8_t buffer[MESSAGE_HEADER_SIZE];
    ASSERT_OK(serialize_header(&header, buffer));
    
    /* Check network byte order (big-endian) */
    /* Magic at offset 0 should be 0x44 0x49 0x53 0x54 ("DIST") */
    ASSERT_TRUE(buffer[0] == 0x44);
    ASSERT_TRUE(buffer[1] == 0x49);
    ASSERT_TRUE(buffer[2] == 0x53);
    ASSERT_TRUE(buffer[3] == 0x54);
    
    /* Payload length at offset 12 should be big-endian */
    uint32_t payload_be = (buffer[12] << 24) | (buffer[13] << 16) | 
                          (buffer[14] << 8) | buffer[15];
    ASSERT_TRUE(payload_be == 0x12345678);
    
    printf("  Network byte order verified\n");
    TEST_PASS();
}

void test_header_validation() {
    TEST_START();
    
    message_header_t header;
    
    /* Valid header */
    ASSERT_OK(message_header_init(&header, MSG_CLIENT_QUERY, 100));
    ASSERT_TRUE(validate_message_header(&header));
    
    /* Invalid magic */
    header.magic = 0xDEADBEEF;
    ASSERT_TRUE(!validate_message_header(&header));
    header.magic = PROTOCOL_MAGIC;
    
    /* Invalid version */
    header.version = 0x9999;
    ASSERT_TRUE(!validate_message_header(&header));
    header.version = PROTOCOL_VERSION;
    
    /* Invalid message type */
    header.msg_type = 0;
    ASSERT_TRUE(!validate_message_header(&header));
    header.msg_type = MSG_CLIENT_QUERY;
    
    /* Payload too large */
    header.payload_len = 20 * 1024 * 1024;  /* 20MB */
    ASSERT_TRUE(!validate_message_header(&header));
    header.payload_len = 100;
    
    /* Reserved field non-zero */
    header.reserved = 1;
    ASSERT_TRUE(!validate_message_header(&header));
    header.reserved = 0;
    
    /* Now valid again */
    ASSERT_TRUE(validate_message_header(&header));
    
    printf("  Validation checks passed\n");
    TEST_PASS();
}

void test_crc32_computation() {
    TEST_START();
    
    message_header_t header;
    ASSERT_OK(message_header_init(&header, MSG_RAFT_APPEND_ENTRIES, 256));
    
    /* Create test payload */
    uint8_t payload[256];
    for (int i = 0; i < 256; i++) {
        payload[i] = (uint8_t)i;
    }
    
    /* Compute CRC */
    ASSERT_OK(compute_header_crc32(&header, payload, 256));
    ASSERT_TRUE(header.crc32 != 0);
    
    printf("  CRC32: 0x%08X\n", header.crc32);
    
    /* Verify CRC */
    ASSERT_TRUE(verify_message_crc32(&header, payload, 256));
    
    printf("  CRC32 computation and verification successful\n");
    TEST_PASS();
}

void test_crc32_detects_corruption() {
    TEST_START();
    
    message_header_t header;
    ASSERT_OK(message_header_init(&header, MSG_GOSSIP_MEMBERSHIP_UPDATE, 128));
    
    uint8_t payload[128];
    memset(payload, 0xAA, 128);
    
    /* Compute valid CRC */
    ASSERT_OK(compute_header_crc32(&header, payload, 128));
    uint32_t original_crc = header.crc32;
    
    /* Verify valid */
    ASSERT_TRUE(verify_message_crc32(&header, payload, 128));
    
    /* Corrupt single bit in payload */
    payload[50] ^= 0x01;
    
    /* CRC should fail */
    ASSERT_TRUE(!verify_message_crc32(&header, payload, 128));
    
    /* Restore payload */
    payload[50] ^= 0x01;
    
    /* Corrupt header field */
    header.msg_type ^= 0x0001;
    
    /* CRC should fail */
    ASSERT_TRUE(!verify_message_crc32(&header, payload, 128));
    
    /* Restore */
    header.msg_type ^= 0x0001;
    header.crc32 = original_crc;
    
    /* Should be valid again */
    ASSERT_TRUE(verify_message_crc32(&header, payload, 128));
    
    printf("  CRC32 detects single-bit corruption\n");
    TEST_PASS();
}

void test_empty_payload_crc() {
    TEST_START();
    
    message_header_t header;
    ASSERT_OK(message_header_init(&header, MSG_GOSSIP_ACK, 0));
    
    /* Compute CRC with no payload */
    ASSERT_OK(compute_header_crc32(&header, NULL, 0));
    ASSERT_TRUE(header.crc32 != 0);
    
    /* Verify */
    ASSERT_TRUE(verify_message_crc32(&header, NULL, 0));
    
    printf("  Empty payload CRC works\n");
    TEST_PASS();
}

void test_message_type_strings() {
    TEST_START();
    
    ASSERT_TRUE(strcmp(message_type_to_string(MSG_RAFT_REQUEST_VOTE), 
                      "RAFT_REQUEST_VOTE") == 0);
    ASSERT_TRUE(strcmp(message_type_to_string(MSG_GOSSIP_PING), 
                      "GOSSIP_PING") == 0);
    ASSERT_TRUE(strcmp(message_type_to_string(MSG_TASK_ASSIGNMENT), 
                      "TASK_ASSIGNMENT") == 0);
    ASSERT_TRUE(strcmp(message_type_to_string(MSG_CLIENT_SUBMIT), 
                      "CLIENT_SUBMIT") == 0);
    ASSERT_TRUE(strcmp(message_type_to_string((message_type_t)0xFFFF), 
                      "UNKNOWN") == 0);
    
    printf("  Message type strings correct\n");
    TEST_PASS();
}

void test_header_size() {
    TEST_START();
    
    /* Verify header is exactly 32 bytes */
    ASSERT_TRUE(sizeof(message_header_t) == MESSAGE_HEADER_SIZE);
    ASSERT_TRUE(MESSAGE_HEADER_SIZE == 32);
    
    printf("  Header size: %zu bytes (expected: 32)\n", 
           sizeof(message_header_t));
    TEST_PASS();
}

void test_all_message_types() {
    TEST_START();
    
    message_type_t types[] = {
        MSG_RAFT_REQUEST_VOTE,
        MSG_RAFT_APPEND_ENTRIES,
        MSG_GOSSIP_PING,
        MSG_GOSSIP_MEMBERSHIP_UPDATE,
        MSG_TASK_ASSIGNMENT,
        MSG_TASK_RESULT,
        MSG_CLIENT_SUBMIT,
        MSG_CLIENT_RESPONSE
    };
    
    for (size_t i = 0; i < sizeof(types) / sizeof(types[0]); i++) {
        message_header_t header;
        ASSERT_OK(message_header_init(&header, types[i], 64));
        ASSERT_TRUE(validate_message_header(&header));
        ASSERT_OK(compute_header_crc32(&header, NULL, 0));
        ASSERT_TRUE(verify_message_crc32(&header, NULL, 0));
    }
    
    printf("  All message types work correctly\n");
    TEST_PASS();
}

void test_portability() {
    TEST_START();
    
    /* Create header on "sender" */
    message_header_t sender_header;
    ASSERT_OK(message_header_init(&sender_header, MSG_RAFT_REQUEST_VOTE, 1024));
    
    uint8_t payload[1024];
    memset(payload, 0x42, 1024);
    
    ASSERT_OK(compute_header_crc32(&sender_header, payload, 1024));
    
    /* Serialize */
    uint8_t wire_buffer[MESSAGE_HEADER_SIZE];
    ASSERT_OK(serialize_header(&sender_header, wire_buffer));
    
    /* Simulate transmission... */
    
    /* Deserialize on "receiver" */
    message_header_t receiver_header;
    ASSERT_OK(deserialize_header(wire_buffer, &receiver_header));
    
    /* Verify all fields survived */
    ASSERT_TRUE(receiver_header.magic == sender_header.magic);
    ASSERT_TRUE(receiver_header.version == sender_header.version);
    ASSERT_TRUE(receiver_header.msg_type == sender_header.msg_type);
    ASSERT_TRUE(receiver_header.payload_len == sender_header.payload_len);
    ASSERT_TRUE(receiver_header.message_id == sender_header.message_id);
    ASSERT_TRUE(receiver_header.crc32 == sender_header.crc32);
    
    /* Verify CRC */
    ASSERT_TRUE(verify_message_crc32(&receiver_header, payload, 1024));
    
    printf("  Portability test passed (sender → wire → receiver)\n");
    TEST_PASS();
}

/* ============================================================================
 * MAIN
 * ========================================================================= */

int main(void) {
    printf("=== DistriC Protocol - Binary Header Tests ===\n");
    
    test_header_size();
    test_header_initialization();
    test_unique_message_ids();
    test_serialization_deserialization();
    test_network_byte_order();
    test_header_validation();
    test_crc32_computation();
    test_crc32_detects_corruption();
    test_empty_payload_crc();
    test_message_type_strings();
    test_all_message_types();
    test_portability();
    
    printf("\n=== Test Results ===\n");
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_failed);
    
    if (tests_failed == 0) {
        printf("\n✓ All binary protocol tests passed!\n");
        printf("✓ Session 2.1 COMPLETE - Ready for Session 2.2 (TLV)\n");
    }
    
    return tests_failed > 0 ? 1 : 0;
}



//####################
// FILE: /tests/test_messages.c
//####################

/**
 * @file test_messages.c
 * @brief Comprehensive tests for protocol message serialization
 * 
 * Tests all message types:
 * - Raft messages (RequestVote, AppendEntries, etc.)
 * - Gossip messages (Ping, Ack, MembershipUpdate)
 * - Task messages (Assignment, Result)
 * - Client messages (Submit, Response)
 */

#include <distric_protocol/messages.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

static int tests_passed = 0;
static int tests_failed = 0;

#define TEST_START() printf("\n[TEST] %s...\n", __func__)
#define TEST_PASS() do { \
    printf("[PASS] %s\n", __func__); \
    tests_passed++; \
} while(0)

#define ASSERT_OK(expr) do { \
    distric_err_t _err = (expr); \
    if (_err != DISTRIC_OK) { \
        fprintf(stderr, "FAIL: %s returned %d\n", #expr, _err); \
        tests_failed++; \
        return; \
    } \
} while(0)

#define ASSERT_TRUE(expr) do { \
    if (!(expr)) { \
        fprintf(stderr, "FAIL: %s is false\n", #expr); \
        tests_failed++; \
        return; \
    } \
} while(0)

#define ASSERT_EQ(a, b) do { \
    if ((a) != (b)) { \
        fprintf(stderr, "FAIL: %s (%lld) != %s (%lld)\n", #a, (long long)(a), #b, (long long)(b)); \
        tests_failed++; \
        return; \
    } \
} while(0)

#define ASSERT_STR_EQ(a, b) do { \
    if (strcmp((a), (b)) != 0) { \
        fprintf(stderr, "FAIL: %s (\"%s\") != %s (\"%s\")\n", #a, (a), #b, (b)); \
        tests_failed++; \
        return; \
    } \
} while(0)

/* ============================================================================
 * RAFT MESSAGE TESTS
 * ========================================================================= */

void test_raft_request_vote() {
    TEST_START();
    
    /* Create message */
    raft_request_vote_t msg = {
        .term = 42,
        .last_log_index = 1000,
        .last_log_term = 41
    };
    strncpy(msg.candidate_id, "coordinator-1", sizeof(msg.candidate_id) - 1);
    
    /* Serialize */
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_raft_request_vote(&msg, &buffer, &len));
    ASSERT_TRUE(buffer != NULL);
    ASSERT_TRUE(len > 0);
    
    printf("  Serialized size: %zu bytes\n", len);
    
    /* Deserialize */
    raft_request_vote_t decoded;
    ASSERT_OK(deserialize_raft_request_vote(buffer, len, &decoded));
    
    /* Verify */
    ASSERT_EQ(decoded.term, 42);
    ASSERT_STR_EQ(decoded.candidate_id, "coordinator-1");
    ASSERT_EQ(decoded.last_log_index, 1000);
    ASSERT_EQ(decoded.last_log_term, 41);
    
    free(buffer);
    TEST_PASS();
}

void test_raft_request_vote_response() {
    TEST_START();
    
    raft_request_vote_response_t msg = {
        .term = 42,
        .vote_granted = true
    };
    strncpy(msg.node_id, "node-5", sizeof(msg.node_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_raft_request_vote_response(&msg, &buffer, &len));
    
    raft_request_vote_response_t decoded;
    ASSERT_OK(deserialize_raft_request_vote_response(buffer, len, &decoded));
    
    ASSERT_EQ(decoded.term, 42);
    ASSERT_TRUE(decoded.vote_granted);
    ASSERT_STR_EQ(decoded.node_id, "node-5");
    
    free(buffer);
    TEST_PASS();
}

void test_raft_append_entries_empty() {
    TEST_START();
    
    /* Heartbeat (no entries) */
    raft_append_entries_t msg = {
        .term = 42,
        .prev_log_index = 999,
        .prev_log_term = 41,
        .leader_commit = 950,
        .entries = NULL,
        .entry_count = 0
    };
    strncpy(msg.leader_id, "leader-1", sizeof(msg.leader_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_raft_append_entries(&msg, &buffer, &len));
    
    printf("  Heartbeat size: %zu bytes\n", len);
    
    raft_append_entries_t decoded;
    ASSERT_OK(deserialize_raft_append_entries(buffer, len, &decoded));
    
    ASSERT_EQ(decoded.term, 42);
    ASSERT_STR_EQ(decoded.leader_id, "leader-1");
    ASSERT_EQ(decoded.prev_log_index, 999);
    ASSERT_EQ(decoded.entry_count, 0);
    
    free_raft_append_entries(&decoded);
    free(buffer);
    TEST_PASS();
}

void test_raft_append_entries_with_entries() {
    TEST_START();
    
    /* Create log entries */
    raft_log_entry_t entries[3];
    
    entries[0].index = 1000;
    entries[0].term = 42;
    entries[0].data = (uint8_t*)"command1";
    entries[0].data_len = 8;
    
    entries[1].index = 1001;
    entries[1].term = 42;
    entries[1].data = (uint8_t*)"command2";
    entries[1].data_len = 8;
    
    entries[2].index = 1002;
    entries[2].term = 42;
    entries[2].data = (uint8_t*)"command3";
    entries[2].data_len = 8;
    
    raft_append_entries_t msg = {
        .term = 42,
        .prev_log_index = 999,
        .prev_log_term = 41,
        .leader_commit = 950,
        .entries = entries,
        .entry_count = 3
    };
    strncpy(msg.leader_id, "leader-1", sizeof(msg.leader_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_raft_append_entries(&msg, &buffer, &len));
    
    printf("  With 3 entries size: %zu bytes\n", len);
    
    raft_append_entries_t decoded;
    ASSERT_OK(deserialize_raft_append_entries(buffer, len, &decoded));
    
    ASSERT_EQ(decoded.entry_count, 3);
    ASSERT_EQ(decoded.entries[0].index, 1000);
    ASSERT_EQ(decoded.entries[1].index, 1001);
    ASSERT_EQ(decoded.entries[2].index, 1002);
    
    /* Verify data */
    ASSERT_TRUE(memcmp(decoded.entries[0].data, "command1", 8) == 0);
    ASSERT_TRUE(memcmp(decoded.entries[1].data, "command2", 8) == 0);
    ASSERT_TRUE(memcmp(decoded.entries[2].data, "command3", 8) == 0);
    
    free_raft_append_entries(&decoded);
    free(buffer);
    TEST_PASS();
}

/* ============================================================================
 * GOSSIP MESSAGE TESTS
 * ========================================================================= */

void test_gossip_ping() {
    TEST_START();
    
    gossip_ping_t msg = {
        .incarnation = 123456,
        .sequence_number = 789
    };
    strncpy(msg.sender_id, "node-1", sizeof(msg.sender_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_gossip_ping(&msg, &buffer, &len));
    
    gossip_ping_t decoded;
    ASSERT_OK(deserialize_gossip_ping(buffer, len, &decoded));
    
    ASSERT_STR_EQ(decoded.sender_id, "node-1");
    ASSERT_EQ(decoded.incarnation, 123456);
    ASSERT_EQ(decoded.sequence_number, 789);
    
    free(buffer);
    TEST_PASS();
}

void test_gossip_ack() {
    TEST_START();
    
    gossip_ack_t msg = {
        .incarnation = 654321,
        .sequence_number = 789
    };
    strncpy(msg.sender_id, "node-2", sizeof(msg.sender_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_gossip_ack(&msg, &buffer, &len));
    
    gossip_ack_t decoded;
    ASSERT_OK(deserialize_gossip_ack(buffer, len, &decoded));
    
    ASSERT_STR_EQ(decoded.sender_id, "node-2");
    ASSERT_EQ(decoded.incarnation, 654321);
    ASSERT_EQ(decoded.sequence_number, 789);
    
    free(buffer);
    TEST_PASS();
}

void test_gossip_membership_update() {
    TEST_START();
    
    /* Create node updates */
    gossip_node_info_t updates[3];
    
    strncpy(updates[0].node_id, "node-1", sizeof(updates[0].node_id) - 1);
    strncpy(updates[0].address, "10.0.1.1", sizeof(updates[0].address) - 1);
    updates[0].port = 9000;
    updates[0].state = NODE_STATE_ALIVE;
    updates[0].role = NODE_ROLE_COORDINATOR;
    updates[0].incarnation = 100;
    
    strncpy(updates[1].node_id, "node-2", sizeof(updates[1].node_id) - 1);
    strncpy(updates[1].address, "10.0.1.2", sizeof(updates[1].address) - 1);
    updates[1].port = 9000;
    updates[1].state = NODE_STATE_ALIVE;
    updates[1].role = NODE_ROLE_COORDINATOR;
    updates[1].incarnation = 101;
    
    strncpy(updates[2].node_id, "worker-1", sizeof(updates[2].node_id) - 1);
    strncpy(updates[2].address, "10.0.2.1", sizeof(updates[2].address) - 1);
    updates[2].port = 9001;
    updates[2].state = NODE_STATE_SUSPECTED;
    updates[2].role = NODE_ROLE_WORKER;
    updates[2].incarnation = 200;
    
    gossip_membership_update_t msg = {
        .updates = updates,
        .update_count = 3
    };
    strncpy(msg.sender_id, "node-1", sizeof(msg.sender_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_gossip_membership_update(&msg, &buffer, &len));
    
    printf("  3 node updates size: %zu bytes\n", len);
    
    gossip_membership_update_t decoded;
    ASSERT_OK(deserialize_gossip_membership_update(buffer, len, &decoded));
    
    ASSERT_STR_EQ(decoded.sender_id, "node-1");
    ASSERT_EQ(decoded.update_count, 3);
    
    /* Verify first node */
    ASSERT_STR_EQ(decoded.updates[0].node_id, "node-1");
    ASSERT_STR_EQ(decoded.updates[0].address, "10.0.1.1");
    ASSERT_EQ(decoded.updates[0].port, 9000);
    ASSERT_EQ(decoded.updates[0].state, NODE_STATE_ALIVE);
    ASSERT_EQ(decoded.updates[0].role, NODE_ROLE_COORDINATOR);
    
    /* Verify third node (suspected worker) */
    ASSERT_STR_EQ(decoded.updates[2].node_id, "worker-1");
    ASSERT_EQ(decoded.updates[2].state, NODE_STATE_SUSPECTED);
    ASSERT_EQ(decoded.updates[2].role, NODE_ROLE_WORKER);
    
    free_gossip_membership_update(&decoded);
    free(buffer);
    TEST_PASS();
}

/* ============================================================================
 * TASK MESSAGE TESTS
 * ========================================================================= */

void test_task_assignment() {
    TEST_START();
    
    uint8_t input_data[] = {0x01, 0x02, 0x03, 0x04};
    
    task_assignment_t msg = {
        .config_json = "{\"threshold\":1000}",
        .input_data = input_data,
        .input_data_len = 4,
        .timeout_sec = 30,
        .retry_count = 3
    };
    strncpy(msg.task_id, "task-123", sizeof(msg.task_id) - 1);
    strncpy(msg.workflow_id, "workflow-456", sizeof(msg.workflow_id) - 1);
    strncpy(msg.task_type, "payment_validator", sizeof(msg.task_type) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_task_assignment(&msg, &buffer, &len));
    
    printf("  Task assignment size: %zu bytes\n", len);
    
    task_assignment_t decoded;
    ASSERT_OK(deserialize_task_assignment(buffer, len, &decoded));
    
    ASSERT_STR_EQ(decoded.task_id, "task-123");
    ASSERT_STR_EQ(decoded.workflow_id, "workflow-456");
    ASSERT_STR_EQ(decoded.task_type, "payment_validator");
    ASSERT_STR_EQ(decoded.config_json, "{\"threshold\":1000}");
    ASSERT_EQ(decoded.input_data_len, 4);
    ASSERT_TRUE(memcmp(decoded.input_data, input_data, 4) == 0);
    ASSERT_EQ(decoded.timeout_sec, 30);
    ASSERT_EQ(decoded.retry_count, 3);
    
    free_task_assignment(&decoded);
    free(buffer);
    TEST_PASS();
}

void test_task_result() {
    TEST_START();
    
    uint8_t output_data[] = "result_data";
    
    task_result_t msg = {
        .status = TASK_STATUS_COMPLETED,
        .output_data = output_data,
        .output_data_len = 11,
        .error_message = NULL,
        .exit_code = 0,
        .started_at = 1000000,
        .completed_at = 1005000
    };
    strncpy(msg.task_id, "task-123", sizeof(msg.task_id) - 1);
    strncpy(msg.worker_id, "worker-1", sizeof(msg.worker_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_task_result(&msg, &buffer, &len));
    
    printf("  Task result size: %zu bytes\n", len);
    
    task_result_t decoded;
    ASSERT_OK(deserialize_task_result(buffer, len, &decoded));
    
    ASSERT_STR_EQ(decoded.task_id, "task-123");
    ASSERT_STR_EQ(decoded.worker_id, "worker-1");
    ASSERT_EQ(decoded.status, TASK_STATUS_COMPLETED);
    ASSERT_EQ(decoded.output_data_len, 11);
    ASSERT_TRUE(memcmp(decoded.output_data, output_data, 11) == 0);
    ASSERT_EQ(decoded.exit_code, 0);
    ASSERT_EQ(decoded.started_at, 1000000);
    ASSERT_EQ(decoded.completed_at, 1005000);
    
    free_task_result(&decoded);
    free(buffer);
    TEST_PASS();
}

/* ============================================================================
 * CLIENT MESSAGE TESTS
 * ========================================================================= */

void test_client_submit() {
    TEST_START();
    
    client_submit_t msg = {
        .payload_json = "{\"amount\":15000,\"user_id\":\"user_123\"}",
        .timestamp = 1700000000000ULL
    };
    strncpy(msg.message_id, "msg-abc123", sizeof(msg.message_id) - 1);
    strncpy(msg.event_type, "payment_received", sizeof(msg.event_type) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_client_submit(&msg, &buffer, &len));
    
    printf("  Client submit size: %zu bytes\n", len);
    
    client_submit_t decoded;
    ASSERT_OK(deserialize_client_submit(buffer, len, &decoded));
    
    ASSERT_STR_EQ(decoded.message_id, "msg-abc123");
    ASSERT_STR_EQ(decoded.event_type, "payment_received");
    ASSERT_STR_EQ(decoded.payload_json, "{\"amount\":15000,\"user_id\":\"user_123\"}");
    ASSERT_EQ(decoded.timestamp, 1700000000000ULL);
    
    free_client_submit(&decoded);
    free(buffer);
    TEST_PASS();
}

void test_client_response() {
    TEST_START();
    
    char* workflows[] = {"fraud_detection", "notification", "analytics"};
    
    client_response_t msg = {
        .response_code = 202,
        .response_message = "Accepted for processing",
        .workflows_triggered = workflows,
        .workflow_count = 3
    };
    strncpy(msg.message_id, "msg-abc123", sizeof(msg.message_id) - 1);
    
    uint8_t* buffer = NULL;
    size_t len = 0;
    ASSERT_OK(serialize_client_response(&msg, &buffer, &len));
    
    printf("  Client response size: %zu bytes\n", len);
    
    client_response_t decoded;
    ASSERT_OK(deserialize_client_response(buffer, len, &decoded));
    
    ASSERT_STR_EQ(decoded.message_id, "msg-abc123");
    ASSERT_EQ(decoded.response_code, 202);
    ASSERT_STR_EQ(decoded.response_message, "Accepted for processing");
    ASSERT_EQ(decoded.workflow_count, 3);
    ASSERT_STR_EQ(decoded.workflows_triggered[0], "fraud_detection");
    ASSERT_STR_EQ(decoded.workflows_triggered[1], "notification");
    ASSERT_STR_EQ(decoded.workflows_triggered[2], "analytics");
    
    free_client_response(&decoded);
    free(buffer);
    TEST_PASS();
}

/* ============================================================================
 * UTILITY FUNCTION TESTS
 * ========================================================================= */

void test_utility_functions() {
    TEST_START();
    
    ASSERT_STR_EQ(node_state_to_string(NODE_STATE_ALIVE), "ALIVE");
    ASSERT_STR_EQ(node_state_to_string(NODE_STATE_SUSPECTED), "SUSPECTED");
    ASSERT_STR_EQ(node_state_to_string(NODE_STATE_FAILED), "FAILED");
    
    ASSERT_STR_EQ(node_role_to_string(NODE_ROLE_COORDINATOR), "COORDINATOR");
    ASSERT_STR_EQ(node_role_to_string(NODE_ROLE_WORKER), "WORKER");
    
    ASSERT_STR_EQ(task_status_to_string(TASK_STATUS_PENDING), "PENDING");
    ASSERT_STR_EQ(task_status_to_string(TASK_STATUS_RUNNING), "RUNNING");
    ASSERT_STR_EQ(task_status_to_string(TASK_STATUS_COMPLETED), "COMPLETED");
    ASSERT_STR_EQ(task_status_to_string(TASK_STATUS_FAILED), "FAILED");
    
    printf("  All utility functions work correctly\n");
    
    TEST_PASS();
}

/* ============================================================================
 * MAIN
 * ========================================================================= */

int main(void) {
    printf("=== DistriC Protocol - Message Serialization Tests ===\n");
    
    /* Raft messages */
    test_raft_request_vote();
    test_raft_request_vote_response();
    test_raft_append_entries_empty();
    test_raft_append_entries_with_entries();
    
    /* Gossip messages */
    test_gossip_ping();
    test_gossip_ack();
    test_gossip_membership_update();
    
    /* Task messages */
    test_task_assignment();
    test_task_result();
    
    /* Client messages */
    test_client_submit();
    test_client_response();
    
    /* Utilities */
    test_utility_functions();
    
    printf("\n=== Test Results ===\n");
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_failed);
    
    if (tests_failed == 0) {
        printf("\n✓ All message serialization tests passed!\n");
        printf("✓ Session 2.3 COMPLETE - Ready for Session 2.4 (RPC Framework)\n");
        printf("\nMessage Types Tested:\n");
        printf("  - Raft: RequestVote, AppendEntries (with/without entries)\n");
        printf("  - Gossip: Ping, Ack, MembershipUpdate\n");
        printf("  - Task: Assignment, Result\n");
        printf("  - Client: Submit, Response\n");
        printf("\nAll messages use TLV encoding for forward compatibility!\n");
    }
    
    return tests_failed > 0 ? 1 : 0;
}



//####################
// FILE: /tests/test_tlv.c
//####################

/**
 * @file test_tlv.c
 * @brief Comprehensive tests for TLV encoder/decoder
 * 
 * Tests:
 * - Basic encoding/decoding of all types
 * - Round-trip verification
 * - Buffer growth
 * - Zero-copy decoding
 * - Forward compatibility (unknown field skipping)
 * - Corruption detection
 * - Edge cases
 */

#include <distric_protocol/tlv.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

static int tests_passed = 0;
static int tests_failed = 0;

#define TEST_START() printf("\n[TEST] %s...\n", __func__)
#define TEST_PASS() do { \
    printf("[PASS] %s\n", __func__); \
    tests_passed++; \
} while(0)

#define ASSERT_OK(expr) do { \
    distric_err_t _err = (expr); \
    if (_err != DISTRIC_OK) { \
        fprintf(stderr, "FAIL: %s returned %d\n", #expr, _err); \
        tests_failed++; \
        return; \
    } \
} while(0)

#define ASSERT_TRUE(expr) do { \
    if (!(expr)) { \
        fprintf(stderr, "FAIL: %s is false\n", #expr); \
        tests_failed++; \
        return; \
    } \
} while(0)

#define ASSERT_EQ(a, b) do { \
    if ((a) != (b)) { \
        fprintf(stderr, "FAIL: %s (%lld) != %s (%lld)\n", #a, (long long)(a), #b, (long long)(b)); \
        tests_failed++; \
        return; \
    } \
} while(0)

/* Test field tags */
#define TAG_TERM            0x0001
#define TAG_CANDIDATE_ID    0x0002
#define TAG_NODE_ID         0x0003
#define TAG_COUNT           0x0004
#define TAG_TIMESTAMP       0x0005
#define TAG_ENABLED         0x0006
#define TAG_MESSAGE         0x0007
#define TAG_DATA            0x0008

/* ============================================================================
 * BASIC ENCODING/DECODING TESTS
 * ========================================================================= */

void test_encode_decode_uint32() {
    TEST_START();
    
    /* Encode */
    tlv_encoder_t* enc = tlv_encoder_create(64);
    ASSERT_TRUE(enc != NULL);
    
    ASSERT_OK(tlv_encode_uint32(enc, TAG_TERM, 42));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    ASSERT_TRUE(buffer != NULL);
    ASSERT_TRUE(len > 0);
    
    printf("  Encoded length: %zu bytes\n", len);
    
    /* Decode */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    ASSERT_TRUE(dec != NULL);
    
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    ASSERT_EQ(field.type, TLV_UINT32);
    ASSERT_EQ(field.tag, TAG_TERM);
    ASSERT_EQ(field.length, sizeof(uint32_t));
    
    uint32_t value;
    ASSERT_OK(tlv_field_get_uint32(&field, &value));
    ASSERT_EQ(value, 42);
    
    printf("  Decoded value: %u\n", value);
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

void test_encode_decode_string() {
    TEST_START();
    
    const char* test_string = "node-12345";
    
    /* Encode */
    tlv_encoder_t* enc = tlv_encoder_create(64);
    ASSERT_OK(tlv_encode_string(enc, TAG_NODE_ID, test_string));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    printf("  Encoded length: %zu bytes\n", len);
    
    /* Decode */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    ASSERT_EQ(field.type, TLV_STRING);
    ASSERT_EQ(field.tag, TAG_NODE_ID);
    
    const char* decoded = tlv_field_get_string(&field);
    ASSERT_TRUE(decoded != NULL);
    ASSERT_TRUE(strcmp(decoded, test_string) == 0);
    
    printf("  Decoded string: \"%s\"\n", decoded);
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

void test_encode_decode_bytes() {
    TEST_START();
    
    uint8_t test_data[256];
    for (int i = 0; i < 256; i++) {
        test_data[i] = (uint8_t)i;
    }
    
    /* Encode */
    tlv_encoder_t* enc = tlv_encoder_create(512);
    ASSERT_OK(tlv_encode_bytes(enc, TAG_DATA, test_data, 256));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    /* Decode */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    ASSERT_EQ(field.type, TLV_BYTES);
    ASSERT_EQ(field.tag, TAG_DATA);
    ASSERT_EQ(field.length, 256);
    
    size_t decoded_len;
    const uint8_t* decoded = tlv_field_get_bytes(&field, &decoded_len);
    ASSERT_TRUE(decoded != NULL);
    ASSERT_EQ(decoded_len, 256);
    
    /* Verify data */
    for (int i = 0; i < 256; i++) {
        ASSERT_EQ(decoded[i], (uint8_t)i);
    }
    
    printf("  256 bytes verified\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

void test_encode_all_numeric_types() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(256);
    
    ASSERT_OK(tlv_encode_uint8(enc, 0x0001, 255));
    ASSERT_OK(tlv_encode_uint16(enc, 0x0002, 65535));
    ASSERT_OK(tlv_encode_uint32(enc, 0x0003, 4294967295U));
    ASSERT_OK(tlv_encode_uint64(enc, 0x0004, 18446744073709551615ULL));
    ASSERT_OK(tlv_encode_int32(enc, 0x0005, -2147483648));
    ASSERT_OK(tlv_encode_int64(enc, 0x0006, -9223372036854775807LL));
    ASSERT_OK(tlv_encode_bool(enc, 0x0007, true));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    printf("  Encoded 7 fields, total size: %zu bytes\n", len);
    
    /* Decode and verify */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    
    /* uint8 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    uint8_t u8;
    ASSERT_OK(tlv_field_get_uint8(&field, &u8));
    ASSERT_EQ(u8, 255);
    
    /* uint16 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    uint16_t u16;
    ASSERT_OK(tlv_field_get_uint16(&field, &u16));
    ASSERT_EQ(u16, 65535);
    
    /* uint32 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    uint32_t u32;
    ASSERT_OK(tlv_field_get_uint32(&field, &u32));
    ASSERT_EQ(u32, 4294967295U);
    
    /* uint64 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    uint64_t u64;
    ASSERT_OK(tlv_field_get_uint64(&field, &u64));
    ASSERT_EQ(u64, 18446744073709551615ULL);
    
    /* int32 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    int32_t i32;
    ASSERT_OK(tlv_field_get_int32(&field, &i32));
    ASSERT_EQ(i32, -2147483648);
    
    /* int64 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    int64_t i64;
    ASSERT_OK(tlv_field_get_int64(&field, &i64));
    ASSERT_EQ(i64, -9223372036854775807LL);
    
    /* bool */
    ASSERT_OK(tlv_decode_next(dec, &field));
    bool b;
    ASSERT_OK(tlv_field_get_bool(&field, &b));
    ASSERT_TRUE(b == true);
    
    printf("  All numeric types verified\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * MULTIPLE FIELDS TEST
 * ========================================================================= */

void test_multiple_fields() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(256);
    
    /* Encode multiple fields (simulating Raft RequestVote) */
    ASSERT_OK(tlv_encode_uint32(enc, TAG_TERM, 42));
    ASSERT_OK(tlv_encode_string(enc, TAG_CANDIDATE_ID, "coordinator-1"));
    ASSERT_OK(tlv_encode_uint32(enc, 0x0010, 1000));  /* last_log_index */
    ASSERT_OK(tlv_encode_uint32(enc, 0x0011, 41));    /* last_log_term */
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    printf("  Encoded 4 fields, total size: %zu bytes\n", len);
    
    /* Decode all fields */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    
    int field_count = 0;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        printf("  Field %d: tag=0x%04X type=%s length=%u\n",
               field_count, field.tag, tlv_type_to_string(field.type), field.length);
        field_count++;
    }
    
    ASSERT_EQ(field_count, 4);
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * BUFFER GROWTH TEST
 * ========================================================================= */

void test_buffer_growth() {
    TEST_START();
    
    /* Start with tiny buffer */
    tlv_encoder_t* enc = tlv_encoder_create(8);
    
    /* Encode data that exceeds initial capacity */
    for (int i = 0; i < 100; i++) {
        ASSERT_OK(tlv_encode_uint32(enc, TAG_COUNT, (uint32_t)i));
    }
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    printf("  Encoded 100 fields, total size: %zu bytes\n", len);
    
    /* Decode and verify */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    
    for (int i = 0; i < 100; i++) {
        ASSERT_OK(tlv_decode_next(dec, &field));
        uint32_t value = tlv_field_as_uint32(&field);
        ASSERT_EQ(value, (uint32_t)i);
    }
    
    printf("  All 100 fields verified\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * FIELD SEARCH TEST
 * ========================================================================= */

void test_find_field() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(256);
    
    /* Encode multiple fields */
    ASSERT_OK(tlv_encode_uint32(enc, 0x0001, 10));
    ASSERT_OK(tlv_encode_uint32(enc, 0x0002, 20));
    ASSERT_OK(tlv_encode_uint32(enc, 0x0003, 30));
    ASSERT_OK(tlv_encode_string(enc, 0x0010, "target"));
    ASSERT_OK(tlv_encode_uint32(enc, 0x0004, 40));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    /* Search for specific field */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    
    ASSERT_OK(tlv_find_field(dec, 0x0010, &field));
    ASSERT_EQ(field.tag, 0x0010);
    
    const char* str = tlv_field_get_string(&field);
    ASSERT_TRUE(strcmp(str, "target") == 0);
    
    printf("  Found target field: \"%s\"\n", str);
    
    /* Search for non-existent field */
    tlv_decoder_reset(dec);
    distric_err_t err = tlv_find_field(dec, 0x9999, &field);
    ASSERT_TRUE(err == DISTRIC_ERR_NOT_FOUND);
    
    printf("  Non-existent field correctly not found\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * FORWARD COMPATIBILITY TEST (unknown field skipping)
 * ========================================================================= */

void test_forward_compatibility() {
    TEST_START();
    
    /* Simulate old encoder creating message with known fields */
    tlv_encoder_t* enc = tlv_encoder_create(256);
    ASSERT_OK(tlv_encode_uint32(enc, TAG_TERM, 1));
    ASSERT_OK(tlv_encode_string(enc, TAG_NODE_ID, "node-1"));
    
    /* Simulate new encoder adding unknown field (type 0xFF) */
    ASSERT_OK(tlv_encode_raw(enc, (tlv_type_t)0xFF, 0x9999, 
                            (const uint8_t*)"future_data", 11));
    
    ASSERT_OK(tlv_encode_uint32(enc, TAG_COUNT, 100));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    /* Old decoder should skip unknown field */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    
    /* Read field 1 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_EQ(field.tag, TAG_TERM);
    
    /* Read field 2 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_EQ(field.tag, TAG_NODE_ID);
    
    /* Read field 3 (unknown type, but decoder doesn't care) */
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_EQ(field.tag, 0x9999);
    ASSERT_EQ(field.type, 0xFF);
    
    /* Read field 4 */
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_EQ(field.tag, TAG_COUNT);
    ASSERT_EQ(tlv_field_as_uint32(&field), 100);
    
    printf("  Old decoder successfully skipped unknown field\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * VALIDATION TEST
 * ========================================================================= */

void test_buffer_validation() {
    TEST_START();
    
    /* Valid buffer */
    tlv_encoder_t* enc = tlv_encoder_create(256);
    ASSERT_OK(tlv_encode_uint32(enc, TAG_TERM, 42));
    ASSERT_OK(tlv_encode_string(enc, TAG_NODE_ID, "test"));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    ASSERT_TRUE(tlv_validate_buffer(buffer, len));
    printf("  Valid buffer accepted\n");
    
    /* Corrupt buffer (truncate) */
    ASSERT_TRUE(!tlv_validate_buffer(buffer, len - 5));
    printf("  Truncated buffer rejected\n");
    
    /* Corrupt buffer (wrong length in header) */
    uint8_t corrupt[256];
    memcpy(corrupt, buffer, len);
    
    /* Modify length field in first TLV header (offset 3-6) */
    *(uint32_t*)(corrupt + 3) = htonl(9999);
    
    ASSERT_TRUE(!tlv_validate_buffer(corrupt, len));
    printf("  Corrupted length field detected\n");
    
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * ZERO-COPY VERIFICATION
 * ========================================================================= */

void test_zero_copy_decoding() {
    TEST_START();
    
    const char* test_string = "This is a test string for zero-copy verification";
    
    tlv_encoder_t* enc = tlv_encoder_create(256);
    ASSERT_OK(tlv_encode_string(enc, TAG_MESSAGE, test_string));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    /* Decode */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    const char* decoded = tlv_field_get_string(&field);
    
    /* Verify pointer is within original buffer (zero-copy) */
    ASSERT_TRUE(decoded >= (const char*)buffer);
    ASSERT_TRUE(decoded < (const char*)(buffer + len));
    
    printf("  Zero-copy verified: decoded pointer is within buffer\n");
    printf("  Buffer range: %p - %p\n", (void*)buffer, (void*)(buffer + len));
    printf("  Decoded ptr:  %p\n", (void*)decoded);
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * EDGE CASES
 * ========================================================================= */

void test_empty_string() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(64);
    ASSERT_OK(tlv_encode_string(enc, TAG_MESSAGE, ""));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    const char* str = tlv_field_get_string(&field);
    ASSERT_TRUE(str != NULL);
    ASSERT_TRUE(strlen(str) == 0);
    
    printf("  Empty string handled correctly\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

void test_zero_length_bytes() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(64);
    ASSERT_OK(tlv_encode_bytes(enc, TAG_DATA, NULL, 0));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    size_t data_len;
    const uint8_t* data = tlv_field_get_bytes(&field, &data_len);
    ASSERT_TRUE(data_len == 0);
    
    printf("  Zero-length byte array handled correctly\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

void test_encoder_reset() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(256);
    
    /* Encode first message */
    ASSERT_OK(tlv_encode_uint32(enc, TAG_TERM, 1));
    size_t len1 = tlv_encoder_size(enc);
    
    /* Reset */
    tlv_encoder_reset(enc);
    ASSERT_EQ(tlv_encoder_size(enc), 0);
    
    /* Encode second message */
    ASSERT_OK(tlv_encode_uint32(enc, TAG_TERM, 2));
    size_t len2 = tlv_encoder_size(enc);
    
    ASSERT_EQ(len1, len2);  /* Same size */
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    /* Verify second message */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_EQ(tlv_field_as_uint32(&field), 2);
    
    printf("  Encoder reset works correctly\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

void test_decoder_reset() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(256);
    ASSERT_OK(tlv_encode_uint32(enc, 0x0001, 10));
    ASSERT_OK(tlv_encode_uint32(enc, 0x0002, 20));
    ASSERT_OK(tlv_encode_uint32(enc, 0x0003, 30));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    
    /* Read all fields */
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    /* Should be at EOF */
    ASSERT_TRUE(!tlv_decoder_has_more(dec));
    
    /* Reset and read again */
    tlv_decoder_reset(dec);
    ASSERT_TRUE(tlv_decoder_has_more(dec));
    
    ASSERT_OK(tlv_decode_next(dec, &field));
    ASSERT_EQ(field.tag, 0x0001);
    
    printf("  Decoder reset works correctly\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

void test_type_mismatch_detection() {
    TEST_START();
    
    tlv_encoder_t* enc = tlv_encoder_create(64);
    ASSERT_OK(tlv_encode_string(enc, TAG_MESSAGE, "not a number"));
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    ASSERT_OK(tlv_decode_next(dec, &field));
    
    /* Try to extract as uint32 (should fail) */
    uint32_t value;
    distric_err_t err = tlv_field_get_uint32(&field, &value);
    ASSERT_TRUE(err == DISTRIC_ERR_TYPE_MISMATCH);
    
    printf("  Type mismatch correctly detected\n");
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * PERFORMANCE TEST
 * ========================================================================= */

void test_performance() {
    TEST_START();
    
    const int COUNT = 10000;
    
    tlv_encoder_t* enc = tlv_encoder_create(1024 * 64);
    
    /* Encode 10,000 fields */
    for (int i = 0; i < COUNT; i++) {
        tlv_encode_uint32(enc, TAG_COUNT, (uint32_t)i);
    }
    
    size_t len;
    uint8_t* buffer = tlv_encoder_finalize(enc, &len);
    
    printf("  Encoded %d fields in %zu bytes\n", COUNT, len);
    printf("  Average bytes per field: %.2f\n", (double)len / COUNT);
    
    /* Decode 10,000 fields */
    tlv_decoder_t* dec = tlv_decoder_create(buffer, len);
    tlv_field_t field;
    
    int decoded_count = 0;
    while (tlv_decode_next(dec, &field) == DISTRIC_OK) {
        decoded_count++;
    }
    
    ASSERT_EQ(decoded_count, COUNT);
    printf("  Decoded %d fields successfully\n", decoded_count);
    
    tlv_decoder_free(dec);
    tlv_encoder_free(enc);
    
    TEST_PASS();
}

/* ============================================================================
 * MAIN
 * ========================================================================= */

int main(void) {
    printf("=== DistriC Protocol - TLV Encoder/Decoder Tests ===\n");
    
    /* Basic tests */
    test_encode_decode_uint32();
    test_encode_decode_string();
    test_encode_decode_bytes();
    test_encode_all_numeric_types();
    
    /* Multiple fields */
    test_multiple_fields();
    
    /* Buffer management */
    test_buffer_growth();
    
    /* Field search */
    test_find_field();
    
    /* Compatibility */
    test_forward_compatibility();
    
    /* Validation */
    test_buffer_validation();
    
    /* Zero-copy */
    test_zero_copy_decoding();
    
    /* Edge cases */
    test_empty_string();
    test_zero_length_bytes();
    test_encoder_reset();
    test_decoder_reset();
    test_type_mismatch_detection();
    
    /* Performance */
    test_performance();
    
    printf("\n=== Test Results ===\n");
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_failed);
    
    if (tests_failed == 0) {
        printf("\n✓ All TLV tests passed!\n");
        printf("✓ Session 2.2 COMPLETE - Ready for Session 2.3 (Message Definitions)\n");
        printf("\nKey Features Verified:\n");
        printf("  - Encode/decode round-trip for all types\n");
        printf("  - Dynamic buffer growth\n");
        printf("  - Zero-copy decoding\n");
        printf("  - Forward compatibility (unknown field skipping)\n");
        printf("  - Buffer validation\n");
        printf("  - Type safety\n");
        printf("  - Performance: ~11 bytes per uint32 field (header + value)\n");
    }
    
    return tests_failed > 0 ? 1 : 0;
}



